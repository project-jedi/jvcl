{-----------------------------------------------------------------------------
The contents of this file are subject to the Mozilla Public License
Version 1.1 (the "License"); you may not use this file except in compliance
with the License. You may obtain a copy of the License at
http://www.mozilla.org/MPL/MPL-1.1.html

Software distributed under the License is distributed on an "AS IS" basis,
WITHOUT WARRANTY OF ANY KIND, either expressed or implied. See the License for
the specific language governing rights and limitations under the License.

The Original Code is: JvExControls.pas, released on 2004-01-04

The Initial Developer of the Original Code is Andreas Hausladen [Andreas dott Hausladen att gmx dott de]
Portions created by Andreas Hausladen are Copyright (C) 2004 Andreas Hausladen.
All Rights Reserved.

Contributor(s): -

You may retrieve the latest version of this file at the Project JEDI's JVCL home page,
located at http://jvcl.sourceforge.net

Known Issues:
-----------------------------------------------------------------------------}
// $Id$

unit JvExControls;

{$I jvcl.inc}

{*****************************************************************************
 * WARNING: Do not edit this file.
 * This file is autogenerated from the source in devtools/JvExVCL/src.
 * If you do it despite this warning your changes will be discarded by the next
 * update of this file. Do your changes in the template files.
 ****************************************************************************}

interface

uses
  {$IFDEF MSWINDOWS}
  Windows,
  {$ENDIF MSWINDOWS}
  {$IFDEF LINUX}
  Libc,
  {$ENDIF LINUX}
  {$IFDEF VCL}
  Messages, Graphics, Controls, Forms,
  {$ENDIF VCL}
  {$IFDEF VisualCLX}
  Qt, QTypes, QGraphics, QControls, QForms, QStdCtrls, QMask, QClipbrd,
  Types, QWindows,
  {$ENDIF VisualCLX}
  Classes, SysUtils,
  JvTypes, JvThemes, JVCLVer;


{$IFDEF VCL}
 {$DEFINE NeedMouseEnterLeave}
{$ENDIF VCL}
{$IFDEF VisualCLX}
 {$IF not declared(PatchedVCLX)}
  {$DEFINE NeedMouseEnterLeave}
 {$IFEND}
{$ENDIF VisualCLX}

type
  TDlgCode = (
    dcWantAllKeys, dcWantArrows, dcWantTab, dcWantChars,
    dcButton,
    dcNative // if dcNative is in the set the native functions are used and DoGetDlgCode is ignored
  );
  TDlgCodes = set of TDlgCode;

  {$IFDEF VisualCLX}
  HWND = QWindows.HWND;
  TClxWindowProc = procedure(var Msg: TMessage) of object;
  {$ENDIF VisualCLX}

const
  dcWantMessage = dcWantAllKeys;

type
  {$IFDEF VCL}
  IPerformControl = interface
    ['{B11AA73D-D7C2-43E5-BED8-8F82DE6152AB}']
    function Perform(Msg: Cardinal; WParam, LParam: Longint): Longint;
  end;
  {$ENDIF VCL}

  IJvControlEvents = interface(IPerformControl)
    ['{61FC57FF-D4DA-4840-B871-63DE804E9921}']
    procedure VisibleChanged;
    procedure EnabledChanged;
    procedure TextChanged;
    procedure FontChanged;
    procedure ColorChanged;
    procedure ParentFontChanged;
    procedure ParentColorChanged;
    procedure ParentShowHintChanged;
    function WantKey(Key: Integer; Shift: TShiftState;
      const KeyText: WideString): Boolean; // CM_DIALOGCHAR
    function HintShow(var HintInfo: THintInfo): Boolean;
    function HitTest(X, Y: Integer): Boolean; // CM_HITTEST
    procedure MouseEnter(AControl: TControl);
    procedure MouseLeave(AControl: TControl);
    procedure DoFocusChanged(Control: TWinControl);
    {$IFDEF VCL}
    procedure SetAutoSize(Value: Boolean);
    {$ENDIF VCL}
  end;

  IJvStdControlEvents = interface(IPerformControl)
    ['{62259013-4F43-44BC-AA8C-9E862F9FEE36}']
    procedure DoBoundsChanged;
    procedure CursorChanged;
    procedure ShowingChanged;
    procedure ShowHintChanged;
    procedure ControlsListChanging(Control: TControl; Inserting: Boolean);
    procedure ControlsListChanged(Control: TControl; Inserting: Boolean);
    procedure DoGetDlgCode(var Code: TDlgCodes); // WM_GETDLGCODE
    procedure DoSetFocus(FocusedWnd: HWND);  // WM_SETFOCUS
    procedure DoKillFocus(FocusedWnd: HWND); // WM_KILLFOCUS
    function DoPaintBackground(Canvas: TCanvas; Param: Integer): Boolean; // WM_ERASEBKGND
  end;


  IJvWinControlEvents = interface(IJvStdControlEvents)
    ['{B5F7FB62-78F0-481D-AFF4-7A24ED6776A0}']
    {$IFDEF VisualCLX}
    function GetDoubleBuffered: Boolean;
    procedure Paint;
    {$ENDIF VisualCLX}
  end;



  IJvCustomControlEvents = interface(IPerformControl)
    ['{7804BD3A-D7A5-4314-9259-6DE08A0DC38A}']
  end;

  IJvEditControlEvents = interface(IPerformControl)
    ['{C1AE5EF8-F6C4-4BD4-879E-17946FD0FBAB}']
    procedure DoClipboardPaste;
    procedure DoClipboardCopy;
    procedure DoClipboardCut;
    procedure DoUndo;
    procedure DoClearText;
  end;

{$IFDEF VCL}
const
  CM_DENYSUBCLASSING = JvThemes.CM_DENYSUBCLASSING;
{$ENDIF VCL}
{$IFDEF VisualCLX}
const
  CM_DENYSUBCLASSING = JvQThemes.CM_DENYSUBCLASSING;
{$ENDIF VisualCLX}

type
  { Add IJvDenySubClassing to the base class list if the control should not
    be themed by the ThemeManager (www.delphi-gems.de).
    This only works with JvExVCL derived classes. }
  IJvDenySubClassing = interface
    ['{76942BC0-2A6E-4DC4-BFC9-8E110DB7F601}']
  end;

{$IFDEF VisualCLX}
const
  CM_FOCUSCHANGED = CM_BASE + 17; // VCL Controls: CM_BASE + 7

type
  TCMFocusChanged = record
    Msg: Cardinal;
    Unused: Integer;
    Sender: TWinControl;
    Result: Longint;
  end;
{$ENDIF VisualCLX}

type
  TJvExControl = class(TControl, IJvControlEvents, IPerformControl)
  {$IFDEF VCL}
  protected
   // IJvControlEvents
    procedure VisibleChanged; dynamic;
    procedure EnabledChanged; dynamic;
    procedure TextChanged; dynamic;
    procedure FontChanged; dynamic;
    procedure ColorChanged; dynamic;
    procedure ParentFontChanged; dynamic;
    procedure ParentColorChanged; dynamic;
    procedure ParentShowHintChanged; dynamic;
    function WantKey(Key: Integer; Shift: TShiftState;
      const KeyText: WideString): Boolean; virtual;
    function HintShow(var HintInfo: THintInfo): Boolean; dynamic;
    function HitTest(X, Y: Integer): Boolean; dynamic;
    procedure MouseEnter(Control: TControl); dynamic;
    procedure MouseLeave(Control: TControl); dynamic;
    {$IFNDEF HASAUTOSIZE}
     {$IFNDEF COMPILER6_UP}
    procedure SetAutoSize(Value: Boolean); virtual;
     {$ENDIF !COMPILER6_UP}
    {$ENDIF !HASAUTOSIZE}
  public
    procedure Dispatch(var Msg); override;
  {$ENDIF VCL}
  {$IFDEF VisualCLX}
  public
    function Perform(Msg: Cardinal; WParam, LParam: Longint): Longint;
    function IsRightToLeft: Boolean;
  protected
    WindowProc: TClxWindowProc;
    procedure WndProc(var Msg: TMessage); virtual;
    procedure MouseEnter(Control: TControl); override;
    procedure MouseLeave(Control: TControl); override;
    procedure ParentColorChanged; override;
  {$ENDIF VisualCLX}
  private
    FHintColor: TColor;
    FSavedHintColor: TColor;
    FMouseOver: Boolean;
    FOnParentColorChanged: TNotifyEvent;
  {$IFDEF NeedMouseEnterLeave}
    FOnMouseEnter: TNotifyEvent;
    FOnMouseLeave: TNotifyEvent;
  protected
    property OnMouseEnter: TNotifyEvent read FOnMouseEnter write FOnMouseEnter;
    property OnMouseLeave: TNotifyEvent read FOnMouseLeave write FOnMouseLeave;
  {$ENDIF NeedMouseEnterLeave}
  protected
    procedure CMFocusChanged(var Msg: TCMFocusChanged); message CM_FOCUSCHANGED;
    procedure DoFocusChanged(Control: TWinControl); dynamic;
    property MouseOver: Boolean read FMouseOver write FMouseOver;
    property HintColor: TColor read FHintColor write FHintColor default clInfoBk;
    property OnParentColorChange: TNotifyEvent read FOnParentColorChanged write FOnParentColorChanged;
  private
  {$IFDEF VCL}
    FAboutJVCL: TJVCLAboutInfo;
  published
    property AboutJVCL: TJVCLAboutInfo read FAboutJVCL write FAboutJVCL stored False;
  {$ENDIF VCL}
  {$IFDEF VisualCLX}
    FAboutJVCLX: TJVCLAboutInfo;
  published
    property AboutJVCLX: TJVCLAboutInfo read FAboutJVCLX write FAboutJVCLX stored False;
  {$ENDIF VisualCLX}
  
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  end;
  TJvExPubControl = class(TJvExControl)
  {$IFDEF VCL}
  published
    property BiDiMode;
    property DragCursor;
    property DragKind;
    property DragMode;
    property ParentBiDiMode;
    property OnEndDock;
    property OnStartDock;
  {$ENDIF VCL}
  end;
  
  TJvExWinControl = class(TWinControl, IJvWinControlEvents, IJvControlEvents, IPerformControl)
  {$IFDEF VCL}
  protected
   // IJvControlEvents
    procedure VisibleChanged; dynamic;
    procedure EnabledChanged; dynamic;
    procedure TextChanged; dynamic;
    procedure FontChanged; dynamic;
    procedure ColorChanged; dynamic;
    procedure ParentFontChanged; dynamic;
    procedure ParentColorChanged; dynamic;
    procedure ParentShowHintChanged; dynamic;
    function WantKey(Key: Integer; Shift: TShiftState;
      const KeyText: WideString): Boolean; virtual;
    function HintShow(var HintInfo: THintInfo): Boolean; dynamic;
    function HitTest(X, Y: Integer): Boolean; dynamic;
    procedure MouseEnter(Control: TControl); dynamic;
    procedure MouseLeave(Control: TControl); dynamic;
    {$IFNDEF HASAUTOSIZE}
     {$IFNDEF COMPILER6_UP}
    procedure SetAutoSize(Value: Boolean); virtual;
     {$ENDIF !COMPILER6_UP}
    {$ENDIF !HASAUTOSIZE}
  public
    procedure Dispatch(var Msg); override;
  protected
   // IJvStdControlEvents
    procedure CursorChanged; dynamic;
    procedure ShowingChanged; dynamic;
    procedure ShowHintChanged; dynamic;
    procedure ControlsListChanging(Control: TControl; Inserting: Boolean); dynamic;
    procedure ControlsListChanged(Control: TControl; Inserting: Boolean); dynamic;
  {$IFDEF JVCLThemesEnabledD56}
  private
    function GetParentBackground: Boolean;
  protected
    procedure SetParentBackground(Value: Boolean); virtual;
    property ParentBackground: Boolean read GetParentBackground write SetParentBackground;
  {$ENDIF JVCLThemesEnabledD56}
  {$ENDIF VCL}
  {$IFDEF VisualCLX}
  public
    function Perform(Msg: Cardinal; WParam, LParam: Longint): Longint;
    function IsRightToLeft: Boolean;
  protected
    WindowProc: TClxWindowProc;
    procedure WndProc(var Msg: TMessage); virtual;
    procedure MouseEnter(Control: TControl); override;
    procedure MouseLeave(Control: TControl); override;
    procedure ParentColorChanged; override;
  protected
    procedure BoundsChanged; override;
    function NeedKey(Key: Integer; Shift: TShiftState;
      const KeyText: WideString): Boolean; override;
    procedure RecreateWnd;
    procedure CreateWnd; dynamic;
    procedure CreateWidget; override;	
  private
    FDoubleBuffered: Boolean;
    function GetDoubleBuffered: Boolean;
    procedure SetDoubleBuffered(Value: Boolean);
  protected
    procedure Painting(Sender: QObjectH; EventRegion: QRegionH); override;
    procedure ColorChanged; override;
  published // asn: change to public in final
    property DoubleBuffered: Boolean read GetDoubleBuffered write SetDoubleBuffered;
  {$ENDIF VisualCLX}
  private
    FHintColor: TColor;
    FSavedHintColor: TColor;
    FMouseOver: Boolean;
    FOnParentColorChanged: TNotifyEvent;
  {$IFDEF NeedMouseEnterLeave}
    FOnMouseEnter: TNotifyEvent;
    FOnMouseLeave: TNotifyEvent;
  protected
    property OnMouseEnter: TNotifyEvent read FOnMouseEnter write FOnMouseEnter;
    property OnMouseLeave: TNotifyEvent read FOnMouseLeave write FOnMouseLeave;
  {$ENDIF NeedMouseEnterLeave}
  protected
    procedure CMFocusChanged(var Msg: TCMFocusChanged); message CM_FOCUSCHANGED;
    procedure DoFocusChanged(Control: TWinControl); dynamic;
    property MouseOver: Boolean read FMouseOver write FMouseOver;
    property HintColor: TColor read FHintColor write FHintColor default clInfoBk;
    property OnParentColorChange: TNotifyEvent read FOnParentColorChanged write FOnParentColorChanged;
  private
  {$IFDEF VCL}
    FAboutJVCL: TJVCLAboutInfo;
  published
    property AboutJVCL: TJVCLAboutInfo read FAboutJVCL write FAboutJVCL stored False;
  {$ENDIF VCL}
  {$IFDEF VisualCLX}
    FAboutJVCLX: TJVCLAboutInfo;
  published
    property AboutJVCLX: TJVCLAboutInfo read FAboutJVCLX write FAboutJVCLX stored False;
  {$ENDIF VisualCLX}
  protected
    procedure DoGetDlgCode(var Code: TDlgCodes); virtual;
    procedure DoSetFocus(FocusedWnd: HWND); dynamic;
    procedure DoKillFocus(FocusedWnd: HWND); dynamic;
    procedure DoBoundsChanged; dynamic;
    function DoPaintBackground(Canvas: TCanvas; Param: Integer): Boolean; virtual;
  {$IFDEF VisualCLX}
  private
    FCanvas: TCanvas;
  protected
    procedure Paint; virtual;
    property Canvas: TCanvas read FCanvas;
  {$ENDIF VisualCLX}
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  end;
  TJvExPubWinControl = class(TJvExWinControl)
  {$IFDEF VCL}
  published
    property BiDiMode;
    property DragCursor;
    property DragKind;
    property DragMode;
    property ParentBiDiMode;
    property OnEndDock;
    property OnStartDock;
  {$ENDIF VCL}
  end;
  

  TJvExGraphicControl = class(TGraphicControl, IJvControlEvents, IPerformControl)
  {$IFDEF VCL}
  protected
   // IJvControlEvents
    procedure VisibleChanged; dynamic;
    procedure EnabledChanged; dynamic;
    procedure TextChanged; dynamic;
    procedure FontChanged; dynamic;
    procedure ColorChanged; dynamic;
    procedure ParentFontChanged; dynamic;
    procedure ParentColorChanged; dynamic;
    procedure ParentShowHintChanged; dynamic;
    function WantKey(Key: Integer; Shift: TShiftState;
      const KeyText: WideString): Boolean; virtual;
    function HintShow(var HintInfo: THintInfo): Boolean; dynamic;
    function HitTest(X, Y: Integer): Boolean; dynamic;
    procedure MouseEnter(Control: TControl); dynamic;
    procedure MouseLeave(Control: TControl); dynamic;
    {$IFNDEF HASAUTOSIZE}
     {$IFNDEF COMPILER6_UP}
    procedure SetAutoSize(Value: Boolean); virtual;
     {$ENDIF !COMPILER6_UP}
    {$ENDIF !HASAUTOSIZE}
  public
    procedure Dispatch(var Msg); override;
  {$ENDIF VCL}
  {$IFDEF VisualCLX}
  public
    function Perform(Msg: Cardinal; WParam, LParam: Longint): Longint;
    function IsRightToLeft: Boolean;
  protected
    WindowProc: TClxWindowProc;
    procedure WndProc(var Msg: TMessage); virtual;
    procedure MouseEnter(Control: TControl); override;
    procedure MouseLeave(Control: TControl); override;
    procedure ParentColorChanged; override;
  {$ENDIF VisualCLX}
  private
    FHintColor: TColor;
    FSavedHintColor: TColor;
    FMouseOver: Boolean;
    FOnParentColorChanged: TNotifyEvent;
  {$IFDEF NeedMouseEnterLeave}
    FOnMouseEnter: TNotifyEvent;
    FOnMouseLeave: TNotifyEvent;
  protected
    property OnMouseEnter: TNotifyEvent read FOnMouseEnter write FOnMouseEnter;
    property OnMouseLeave: TNotifyEvent read FOnMouseLeave write FOnMouseLeave;
  {$ENDIF NeedMouseEnterLeave}
  protected
    procedure CMFocusChanged(var Msg: TCMFocusChanged); message CM_FOCUSCHANGED;
    procedure DoFocusChanged(Control: TWinControl); dynamic;
    property MouseOver: Boolean read FMouseOver write FMouseOver;
    property HintColor: TColor read FHintColor write FHintColor default clInfoBk;
    property OnParentColorChange: TNotifyEvent read FOnParentColorChanged write FOnParentColorChanged;
  private
  {$IFDEF VCL}
    FAboutJVCL: TJVCLAboutInfo;
  published
    property AboutJVCL: TJVCLAboutInfo read FAboutJVCL write FAboutJVCL stored False;
  {$ENDIF VCL}
  {$IFDEF VisualCLX}
    FAboutJVCLX: TJVCLAboutInfo;
  published
    property AboutJVCLX: TJVCLAboutInfo read FAboutJVCLX write FAboutJVCLX stored False;
  {$ENDIF VisualCLX}
  
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  {$IFDEF VisualCLX}
  private
    FText: TCaption; // TControl does not save the Caption property
  protected
    function GetText: TCaption; override;
    procedure SetText(const Value: TCaption); override;
    procedure PaintRequest; override;
  {$ENDIF VisualCLX}
  end;
  TJvExPubGraphicControl = class(TJvExGraphicControl)
  {$IFDEF VCL}
  published
    property BiDiMode;
    property DragCursor;
    property DragKind;
    property DragMode;
    property ParentBiDiMode;
    property OnEndDock;
    property OnStartDock;
  {$ENDIF VCL}
  end;
  

  {$UNDEF CONSTRUCTORCODE}
  {$DEFINE CONSTRUCTORCODE DoubleBuffered := True;}
  TJvExCustomControl = class(TCustomControl,   IJvWinControlEvents, IJvCustomControlEvents, IJvControlEvents, IPerformControl)
  {$IFDEF VCL}
  protected
   // IJvControlEvents
    procedure VisibleChanged; dynamic;
    procedure EnabledChanged; dynamic;
    procedure TextChanged; dynamic;
    procedure FontChanged; dynamic;
    procedure ColorChanged; dynamic;
    procedure ParentFontChanged; dynamic;
    procedure ParentColorChanged; dynamic;
    procedure ParentShowHintChanged; dynamic;
    function WantKey(Key: Integer; Shift: TShiftState;
      const KeyText: WideString): Boolean; virtual;
    function HintShow(var HintInfo: THintInfo): Boolean; dynamic;
    function HitTest(X, Y: Integer): Boolean; dynamic;
    procedure MouseEnter(Control: TControl); dynamic;
    procedure MouseLeave(Control: TControl); dynamic;
    {$IFNDEF HASAUTOSIZE}
     {$IFNDEF COMPILER6_UP}
    procedure SetAutoSize(Value: Boolean); virtual;
     {$ENDIF !COMPILER6_UP}
    {$ENDIF !HASAUTOSIZE}
  public
    procedure Dispatch(var Msg); override;
  protected
   // IJvStdControlEvents
    procedure CursorChanged; dynamic;
    procedure ShowingChanged; dynamic;
    procedure ShowHintChanged; dynamic;
    procedure ControlsListChanging(Control: TControl; Inserting: Boolean); dynamic;
    procedure ControlsListChanged(Control: TControl; Inserting: Boolean); dynamic;
  {$IFDEF JVCLThemesEnabledD56}
  private
    function GetParentBackground: Boolean;
  protected
    procedure SetParentBackground(Value: Boolean); virtual;
    property ParentBackground: Boolean read GetParentBackground write SetParentBackground;
  {$ENDIF JVCLThemesEnabledD56}
  {$ENDIF VCL}
  {$IFDEF VisualCLX}
  public
    function Perform(Msg: Cardinal; WParam, LParam: Longint): Longint;
    function IsRightToLeft: Boolean;
  protected
    WindowProc: TClxWindowProc;
    procedure WndProc(var Msg: TMessage); virtual;
    procedure MouseEnter(Control: TControl); override;
    procedure MouseLeave(Control: TControl); override;
    procedure ParentColorChanged; override;
  protected
    procedure BoundsChanged; override;
    function NeedKey(Key: Integer; Shift: TShiftState;
      const KeyText: WideString): Boolean; override;
    procedure RecreateWnd;
    procedure CreateWnd; dynamic;
    procedure CreateWidget; override;	
  private
    FDoubleBuffered: Boolean;
    function GetDoubleBuffered: Boolean;
    procedure SetDoubleBuffered(Value: Boolean);
  protected
    procedure Painting(Sender: QObjectH; EventRegion: QRegionH); override;
    procedure ColorChanged; override;
  published // asn: change to public in final
    property DoubleBuffered: Boolean read GetDoubleBuffered write SetDoubleBuffered;
  {$ENDIF VisualCLX}
  private
    FHintColor: TColor;
    FSavedHintColor: TColor;
    FMouseOver: Boolean;
    FOnParentColorChanged: TNotifyEvent;
  {$IFDEF NeedMouseEnterLeave}
    FOnMouseEnter: TNotifyEvent;
    FOnMouseLeave: TNotifyEvent;
  protected
    property OnMouseEnter: TNotifyEvent read FOnMouseEnter write FOnMouseEnter;
    property OnMouseLeave: TNotifyEvent read FOnMouseLeave write FOnMouseLeave;
  {$ENDIF NeedMouseEnterLeave}
  protected
    procedure CMFocusChanged(var Msg: TCMFocusChanged); message CM_FOCUSCHANGED;
    procedure DoFocusChanged(Control: TWinControl); dynamic;
    property MouseOver: Boolean read FMouseOver write FMouseOver;
    property HintColor: TColor read FHintColor write FHintColor default clInfoBk;
    property OnParentColorChange: TNotifyEvent read FOnParentColorChanged write FOnParentColorChanged;
  private
  {$IFDEF VCL}
    FAboutJVCL: TJVCLAboutInfo;
  published
    property AboutJVCL: TJVCLAboutInfo read FAboutJVCL write FAboutJVCL stored False;
  {$ENDIF VCL}
  {$IFDEF VisualCLX}
    FAboutJVCLX: TJVCLAboutInfo;
  published
    property AboutJVCLX: TJVCLAboutInfo read FAboutJVCLX write FAboutJVCLX stored False;
  {$ENDIF VisualCLX}
  protected
    procedure DoGetDlgCode(var Code: TDlgCodes); virtual;
    procedure DoSetFocus(FocusedWnd: HWND); dynamic;
    procedure DoKillFocus(FocusedWnd: HWND); dynamic;
    procedure DoBoundsChanged; dynamic;
    function DoPaintBackground(Canvas: TCanvas; Param: Integer): Boolean; virtual;
  
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  end;
  TJvExPubCustomControl = class(TJvExCustomControl)
  {$IFDEF VCL}
  published
    property BiDiMode;
    property DragCursor;
    property DragKind;
    property DragMode;
    property ParentBiDiMode;
    property OnEndDock;
    property OnStartDock;
  {$ENDIF VCL}
  end;
  
  {$UNDEF CONSTRUCTORCODE}
  {$DEFINE CONSTRUCTORCODE}

  TJvExHintWindow = class(THintWindow,   IJvWinControlEvents, IJvCustomControlEvents, IJvControlEvents, IPerformControl)
  {$IFDEF VCL}
  protected
   // IJvControlEvents
    procedure VisibleChanged; dynamic;
    procedure EnabledChanged; dynamic;
    procedure TextChanged; dynamic;
    procedure FontChanged; dynamic;
    procedure ColorChanged; dynamic;
    procedure ParentFontChanged; dynamic;
    procedure ParentColorChanged; dynamic;
    procedure ParentShowHintChanged; dynamic;
    function WantKey(Key: Integer; Shift: TShiftState;
      const KeyText: WideString): Boolean; virtual;
    function HintShow(var HintInfo: THintInfo): Boolean; dynamic;
    function HitTest(X, Y: Integer): Boolean; dynamic;
    procedure MouseEnter(Control: TControl); dynamic;
    procedure MouseLeave(Control: TControl); dynamic;
    {$IFNDEF HASAUTOSIZE}
     {$IFNDEF COMPILER6_UP}
    procedure SetAutoSize(Value: Boolean); virtual;
     {$ENDIF !COMPILER6_UP}
    {$ENDIF !HASAUTOSIZE}
  public
    procedure Dispatch(var Msg); override;
  protected
   // IJvStdControlEvents
    procedure CursorChanged; dynamic;
    procedure ShowingChanged; dynamic;
    procedure ShowHintChanged; dynamic;
    procedure ControlsListChanging(Control: TControl; Inserting: Boolean); dynamic;
    procedure ControlsListChanged(Control: TControl; Inserting: Boolean); dynamic;
  {$IFDEF JVCLThemesEnabledD56}
  private
    function GetParentBackground: Boolean;
  protected
    procedure SetParentBackground(Value: Boolean); virtual;
    property ParentBackground: Boolean read GetParentBackground write SetParentBackground;
  {$ENDIF JVCLThemesEnabledD56}
  {$ENDIF VCL}
  {$IFDEF VisualCLX}
  public
    function Perform(Msg: Cardinal; WParam, LParam: Longint): Longint;
    function IsRightToLeft: Boolean;
  protected
    WindowProc: TClxWindowProc;
    procedure WndProc(var Msg: TMessage); virtual;
    procedure MouseEnter(Control: TControl); override;
    procedure MouseLeave(Control: TControl); override;
    procedure ParentColorChanged; override;
  protected
    procedure BoundsChanged; override;
    function NeedKey(Key: Integer; Shift: TShiftState;
      const KeyText: WideString): Boolean; override;
    procedure RecreateWnd;
    procedure CreateWnd; dynamic;
    procedure CreateWidget; override;	
  private
    FDoubleBuffered: Boolean;
    function GetDoubleBuffered: Boolean;
    procedure SetDoubleBuffered(Value: Boolean);
  protected
    procedure Painting(Sender: QObjectH; EventRegion: QRegionH); override;
    procedure ColorChanged; override;
  published // asn: change to public in final
    property DoubleBuffered: Boolean read GetDoubleBuffered write SetDoubleBuffered;
  {$ENDIF VisualCLX}
  private
    FHintColor: TColor;
    FSavedHintColor: TColor;
    FMouseOver: Boolean;
    FOnParentColorChanged: TNotifyEvent;
  {$IFDEF NeedMouseEnterLeave}
    FOnMouseEnter: TNotifyEvent;
    FOnMouseLeave: TNotifyEvent;
  protected
    property OnMouseEnter: TNotifyEvent read FOnMouseEnter write FOnMouseEnter;
    property OnMouseLeave: TNotifyEvent read FOnMouseLeave write FOnMouseLeave;
  {$ENDIF NeedMouseEnterLeave}
  protected
    procedure CMFocusChanged(var Msg: TCMFocusChanged); message CM_FOCUSCHANGED;
    procedure DoFocusChanged(Control: TWinControl); dynamic;
    property MouseOver: Boolean read FMouseOver write FMouseOver;
    property HintColor: TColor read FHintColor write FHintColor default clInfoBk;
    property OnParentColorChange: TNotifyEvent read FOnParentColorChanged write FOnParentColorChanged;
  private
  {$IFDEF VCL}
    FAboutJVCL: TJVCLAboutInfo;
  published
    property AboutJVCL: TJVCLAboutInfo read FAboutJVCL write FAboutJVCL stored False;
  {$ENDIF VCL}
  {$IFDEF VisualCLX}
    FAboutJVCLX: TJVCLAboutInfo;
  published
    property AboutJVCLX: TJVCLAboutInfo read FAboutJVCLX write FAboutJVCLX stored False;
  {$ENDIF VisualCLX}
  protected
    procedure DoGetDlgCode(var Code: TDlgCodes); virtual;
    procedure DoSetFocus(FocusedWnd: HWND); dynamic;
    procedure DoKillFocus(FocusedWnd: HWND); dynamic;
    procedure DoBoundsChanged; dynamic;
    function DoPaintBackground(Canvas: TCanvas; Param: Integer): Boolean; virtual;
  
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  end;
  TJvExPubHintWindow = class(TJvExHintWindow)
  {$IFDEF VCL}
  published
    property BiDiMode;
    property DragCursor;
    property DragKind;
    property DragMode;
    property ParentBiDiMode;
    property OnEndDock;
    property OnStartDock;
  {$ENDIF VCL}
  end;
  

{$IFDEF VCL}

function ShiftStateToKeyData(Shift: TShiftState): Longint;

function InheritMsgEx(Instance: TControl; Msg: Integer; WParam, LParam: Integer): Integer; overload;
function InheritMsg(Instance: TControl; Msg: Integer): Integer; overload;
procedure InheritMessage(Instance: TControl; var Msg: TMessage); overload;
procedure DispatchMsg(Instance: TControl; var Msg);

// jump targets:

procedure Control_ControlsListChanging(Instance: TControl; Control: TControl;
  Inserting: Boolean);
procedure Control_ControlsListChanged(Instance: TControl; Control: TControl;
  Inserting: Boolean);

{$IFDEF COMPILER5}
procedure TOpenControl_SetAutoSize(Instance: TControl; Value: Boolean);
{$ENDIF COMPILER5}

{$ENDIF VCL}

{$IFDEF VCL}
procedure Control_MouseEnter(Instance, Control: TControl; var FMouseOver: Boolean;
  var FSavedHintColor: TColor; FHintColor: TColor; var Event: TNotifyEvent);
{$ENDIF VCL}
{$IFDEF VisualCLX}
procedure Control_MouseEnter(Instance, Control: TControl; var FMouseOver: Boolean;
  var FSavedHintColor: TColor; FHintColor: TColor);
{$ENDIF VisualCLX}

{$IFDEF VCL}
procedure Control_MouseLeave(Instance, Control: TControl; var FMouseOver: Boolean;
  var FSavedHintColor: TColor; var Event: TNotifyEvent);
{$ENDIF VCL}
{$IFDEF VisualCLX}
procedure Control_MouseLeave(Instance, Control: TControl; var FMouseOver: Boolean; FSavedHintColor: TColor);
{$ENDIF VisualCLX}

function DefaultDoPaintBackground(Instance: TWinControl; Canvas: TCanvas; Param: Integer): Boolean;

{$IFDEF VisualCLX}
procedure WidgetControl_Painting(Instance: TWidgetControl; Canvas: TCanvas;
  EventRegion: QRegionH);
  // - redirects Canvas.Handle to a Pixmap if Instance.DoubleBuffered is set
  // - calls Instance.Paint
procedure WidgetControl_DefaultPaint(Instance: TWidgetControl; Canvas: TCanvas);

function TWidgetControl_NeedKey(Instance: TWidgetControl; Key: Integer;
  Shift: TShiftState; const KeyText: WideString; InheritedValue: Boolean): Boolean;

procedure TWidgetControl_ColorChanged(Instance: TWidgetControl);
{$ENDIF VisualCLX}

procedure TCustomEdit_Undo(Instance: TWinControl);
procedure TCustomEdit_Copy(Instance: TWinControl);
procedure TCustomEdit_Paste(Instance: TWinControl);
procedure TCustomEdit_Cut(Instance: TWinControl);

implementation

{$IFDEF VCL}

function ShiftStateToKeyData(Shift: TShiftState): Longint;
const
  AltMask = $20000000;
begin
  Result := 0;
  if ssAlt in Shift then
    Result := Result or AltMask;
end;

type
  PInterface = ^IInterface;

  TFreeNotificationHelper = class(TComponent)
  private
    FInstance: TComponent;
    FIntfPtr: PInterface;
  protected
    procedure Notification(Component: TComponent; Operation: TOperation); override;
  public
    constructor Create(AInstance: TComponent; AIntfPtr: PInterface); reintroduce;
    destructor Destroy; override;
    function IsValid: Boolean;
  end;

constructor TFreeNotificationHelper.Create(AInstance: TComponent; AIntfPtr: PInterface);
begin
  inherited Create(nil);
  FIntfPtr := AIntfPtr;
  if csDestroying in AInstance.ComponentState then
    FInstance := nil
  else
  begin
    FInstance := AInstance;
    FInstance.FreeNotification(Self);
  end;
end;

destructor TFreeNotificationHelper.Destroy;
begin
  if Assigned(FInstance) then
    FInstance.RemoveFreeNotification(Self);
  inherited Destroy;
end;

function TFreeNotificationHelper.IsValid: Boolean;
begin
  Result := FIntfPtr <> nil;
end;

procedure TFreeNotificationHelper.Notification(Component: TComponent; Operation: TOperation);
begin
  if (Operation = opRemove) and (Component = FInstance) then
  begin
   // (ahuser) The component destroys the whole list so the following line could
   //          be removed (but who knowns what the Delphi IDE will do without
   //          this line.
    FInstance.RemoveFreeNotification(Self);
    FInstance := nil;
    FIntfPtr^ := nil;
    FIntfPtr := nil;
  end;
end;


function InheritMsgEx(Instance: TControl; Msg: Integer; WParam, LParam: Integer): Integer;
var
  Mesg: TMessage;
begin
  Mesg.Msg := Msg;
  Mesg.WParam := WParam;
  Mesg.LParam := LParam;
  Mesg.Result := 0;
  InheritMessage(Instance, Mesg);
  Result := Mesg.Result;
end;

function InheritMsg(Instance: TControl; Msg: Integer): Integer;
begin
  Result := InheritMsgEx(Instance, Msg, 0, 0);
end;

procedure InheritMessage(Instance: TControl; var Msg: TMessage);
type
  TDispatchMethod = procedure(Self: TObject; var Msg: TMessage);
var
  Proc: TDispatchMethod;
begin
  Proc := @TObject.Dispatch;
  Proc(Instance, Msg);
end;

procedure DispatchMsg(Instance: TControl; var Msg);
var
  Temp: IJvDenySubClassing;
  IntfControl: IJvControlEvents;
  IntfWinControl: IJvWinControlEvents;
  IntfEditControl: IJvEditControlEvents;
  PMsg: PMessage;
  CallInherited: Boolean;
  Canvas: TCanvas;
  DlgCodes: TDlgCodes;
  IdSaveDC: Integer;
  Helper: TFreeNotificationHelper;
begin
  CallInherited := True;
  PMsg := @Msg;

  if PMsg^.Msg = CM_DENYSUBCLASSING then
  begin
    PMsg^.Result := Ord(Instance.GetInterface(IJvDenySubClassing, Temp));
    Temp := nil; // does not destroy the control because it is derived from TComponent
   // Let the control handle CM_DENYSUBCLASSING the old way, too.
  end;

  { GetInterface is no problem because Instance is a TComponent derived class that
    is not released by an interface "Release". }
  if Instance.GetInterface(IJvControlEvents, IntfControl) then
  begin
    CallInherited := False;
    try
      with IntfControl do
        case PMsg^.Msg of
          CM_VISIBLECHANGED:
            VisibleChanged;
          CM_ENABLEDCHANGED:
            EnabledChanged;
          CM_FONTCHANGED:
            FontChanged;
          CM_COLORCHANGED:
            ColorChanged;
          CM_PARENTFONTCHANGED:
            ParentFontChanged;
          CM_PARENTCOLORCHANGED:
            ParentColorChanged;
          CM_PARENTSHOWHINTCHANGED:
            ParentShowHintChanged;
          CM_TEXTCHANGED:
            TextChanged;
          CM_HINTSHOW:
            PMsg^.Result := Integer(HintShow(TCMHintShow(PMsg^).HintInfo^));
          CM_HITTEST:
            with TCMHitTest(PMsg^) do
              Result := Integer(HitTest(XPos, YPos));
          CM_MOUSEENTER:
              MouseEnter(TControl(PMsg^.LParam));
          CM_MOUSELEAVE:
              MouseLeave(TControl(PMsg^.LParam));
          CM_DIALOGCHAR:
            with TCMDialogChar(PMsg^) do
              Result := Ord(WantKey(CharCode, KeyDataToShiftState(KeyData), WideChar(CharCode)));
          // CM_FOCUSCHANGED: handled by a message handler in the JvExVCL classes
        else
          CallInherited := True;
        end;
    finally
      IntfControl := nil;
    end;
  end;

  if CallInherited then
  begin
    if Instance.GetInterface(IJvWinControlEvents, IntfWinControl) then
    begin
      CallInherited := False;
      try
        with IntfWinControl do
          case PMsg^.Msg of
            CM_CURSORCHANGED:
              CursorChanged;
            CM_SHOWINGCHANGED:
              ShowingChanged;
            CM_SHOWHINTCHANGED:
              ShowHintChanged;
            CM_CONTROLLISTCHANGE:
              if PMsg^.LParam <> 0 then
                ControlsListChanging(TControl(PMsg^.WParam), True)
              else
                ControlsListChanged(TControl(PMsg^.WParam), False);
            CM_CONTROLCHANGE:
              if PMsg^.LParam = 0 then
                ControlsListChanging(TControl(PMsg^.WParam), False)
              else
                ControlsListChanged(TControl(PMsg^.WParam), True);
            WM_GETDLGCODE:
              begin
                Helper := TFreeNotificationHelper.Create(Instance, @IntfWinControl);
                try
                  InheritMessage(Instance, PMsg^);

                  DlgCodes := [dcNative];
                  if PMsg^.Result and DLGC_WANTARROWS <> 0 then
                    Include(DlgCodes, dcWantArrows);
                  if PMsg^.Result and DLGC_WANTTAB <> 0 then
                    Include(DlgCodes, dcWantTab);
                  if PMsg^.Result and DLGC_WANTALLKEYS <> 0 then
                    Include(DlgCodes, dcWantAllKeys);
                  if PMsg^.Result and DLGC_WANTCHARS <> 0 then
                    Include(DlgCodes, dcWantChars);
                  if PMsg^.Result and DLGC_BUTTON <> 0 then
                    Include(DlgCodes, dcButton);

                  if Helper.IsValid then
                  begin
                    DoGetDlgCode(DlgCodes);

                    if not (dcNative in DlgCodes) then
                    begin
                      PMsg^.Result := 0;
                      if dcWantAllKeys in DlgCodes then
                        PMsg^.Result := PMsg^.Result or DLGC_WANTALLKEYS;
                      if dcWantArrows in DlgCodes then
                        PMsg^.Result := PMsg^.Result or DLGC_WANTARROWS;
                      if dcWantTab in DlgCodes then
                        PMsg^.Result := PMsg^.Result or DLGC_WANTTAB;
                      if dcWantChars in DlgCodes then
                        PMsg^.Result := PMsg^.Result or DLGC_WANTCHARS;
                      if dcButton in DlgCodes then
                        PMsg^.Result := PMsg^.Result or DLGC_BUTTON;
                    end;
                  end;
                finally
                  Helper.Free;
                end;
              end;
            WM_SETFOCUS:
              begin
                Helper := TFreeNotificationHelper.Create(Instance, @IntfWinControl);
                try
                  InheritMessage(Instance, PMsg^);
                  if Helper.IsValid then
                    DoSetFocus(HWND(PMsg^.WParam));
                finally
                  Helper.Free;
                end;
              end;
            WM_KILLFOCUS:
              begin
                Helper := TFreeNotificationHelper.Create(Instance, @IntfWinControl);
                try
                  InheritMessage(Instance, PMsg^);
                  if Helper.IsValid then
                    DoKillFocus(HWND(PMsg^.WParam));
                finally
                  Helper.Free;
                end;
              end;
            WM_SIZE:
              begin
                DoBoundsChanged;
                IntfWinControl := nil;
                InheritMessage(Instance, PMsg^);
              end;
            WM_ERASEBKGND:
              begin
                IdSaveDC := SaveDC(HDC(PMsg^.WParam)); // protect DC against Stock-Objects from Canvas
                Canvas := TCanvas.Create;
                try
                  Canvas.Handle := HDC(PMsg^.WParam);
                  PMsg^.Result := Ord(DoPaintBackground(Canvas, PMsg^.LParam));
                finally
                  Canvas.Handle := 0;
                  Canvas.Free;
                  RestoreDC(HDC(PMsg^.WParam), IdSaveDC);
                end;
              end;
            WM_PRINTCLIENT,
            WM_PRINT:
              begin
                IdSaveDC := SaveDC(HDC(PMsg^.WParam)); // protect DC against changes
                try
                  InheritMessage(Instance, PMsg^);
                finally
                  RestoreDC(HDC(PMsg^.WParam), IdSaveDC);
                end;
              end;
          else
            CallInherited := True;
        end;
      finally
        IntfWinControl := nil;
      end;
    end;
  end;

  if CallInherited then
  begin
    if Instance.GetInterface(IJvEditControlEvents, IntfEditControl) then
    begin
      CallInherited := False;
      try
        with IntfEditControl do
          case PMsg^.Msg of
            WM_PASTE:
              begin
                DoClipboardPaste;
                PMsg^.Result := 1;
              end;
            WM_COPY:
              begin
                // The PSDK documentation says that WM_COPY does not has a result
                // value. This is wrong. WM_COPY returns the number of chars that
                // were copied to the clipboard. Unfortunatelly does the CLX methods
                // have no return value and so return 1. If we do not do this
                // WM_CUT will not work.
                DoClipboardCopy;
                PMsg^.Result := 1;
              end;
            WM_CUT:
              begin
                DoClipboardCut;
                PMsg^.Result := 1;
              end;
            WM_UNDO, EM_UNDO:
              begin
                DoUndo;
                PMsg^.Result := 1;
              end;
            WM_CLEAR:
              begin
                DoClearText;
                PMsg^.Result := 1;
              end;
          else
            CallInherited := True;
          end;
      finally
        IntfEditControl := nil;
      end;
    end;
  end;

  if CallInherited then
    InheritMessage(Instance, PMsg^);
end;

{ VCL sends CM_CONTROLLISTCHANGE and CM_CONTROLCHANGE in an other order than
  the CLX methods are used. So we must correct it by evaluating "Inserting". }
procedure Control_ControlsListChanging(Instance: TControl; Control: TControl;
  Inserting: Boolean);
begin
  if Inserting then
    InheritMsgEx(Instance, CM_CONTROLLISTCHANGE, Integer(Control), Integer(Inserting))
  else
    InheritMsgEx(Instance, CM_CONTROLCHANGE, Integer(Control), Integer(Inserting))
end;

procedure Control_ControlsListChanged(Instance: TControl; Control: TControl;
  Inserting: Boolean);
begin
  if not Inserting then
    InheritMsgEx(Instance, CM_CONTROLLISTCHANGE, Integer(Control), Integer(Inserting))
  else
    InheritMsgEx(Instance, CM_CONTROLCHANGE, Integer(Control), Integer(Inserting))
end;

{$ENDIF VCL}

{$IFDEF VCL}
procedure Control_MouseEnter(Instance, Control: TControl; var FMouseOver: Boolean;
  var FSavedHintColor: TColor; FHintColor: TColor; var Event: TNotifyEvent);
{$ENDIF VCL}
{$IFDEF VisualCLX}
procedure Control_MouseEnter(Instance, Control: TControl; var FMouseOver: Boolean;
  var FSavedHintColor: TColor; FHintColor: TColor);
{$ENDIF VisualCLX}
begin
  // (HEG) VCL: Control is nil iff Instance is the control that the mouse has left.
  // Otherwise this is just a notification that the mouse entered
  // one of it's child controls
  if {$IFDEF VCL}(Control = nil) and{$ENDIF} not FMouseOver and not (csDesigning in Instance.ComponentState) then
  begin
    FMouseOver := True;
    FSavedHintColor := Application.HintColor;
    if FHintColor <> clNone then
      Application.HintColor := FHintColor;
    {$IFDEF VCL}
    if Assigned(Event) then
      Event(Instance);
    {$ENDIF VCL}
  end;
  {$IFDEF VCL}
  InheritMsgEx(Instance, CM_MOUSEENTER, 0, Integer(Control));
  {$ENDIF VCL}
end;

{$IFDEF VCL}
procedure Control_MouseLeave(Instance, Control: TControl; var FMouseOver: Boolean;
  var FSavedHintColor: TColor; var Event: TNotifyEvent);
{$ENDIF VCL}
{$IFDEF VisualCLX}
procedure Control_MouseLeave(Instance, Control: TControl; var FMouseOver: Boolean; FSavedHintColor: TColor);
{$ENDIF VisualCLX}
begin
  // (HEG) Control is nil iff Instance is the control that the mouse has left.
  // Otherwise this is just a notification that the mouse left
  // one of it's child controls
  if {$IFDEF VCL}(Control = nil) and{$ENDIF} FMouseOver and not (csDesigning in Instance.ComponentState) then
  begin
    FMouseOver := False;
    Application.HintColor := FSavedHintColor;
    {$IFDEF VCL}
    if Assigned(Event) then
      Event(Instance);
    {$ENDIF VCL}
  end;
  {$IFDEF VCL}
  InheritMsgEx(Instance, CM_MOUSELEAVE, 0, Integer(Control));
  {$ENDIF VCL}
end;

function DefaultDoPaintBackground(Instance: TWinControl; Canvas: TCanvas; Param: Integer): Boolean;
begin
  {$IFDEF VCL}
  Result := InheritMsgEx(Instance, WM_ERASEBKGND, Canvas.Handle, Param) <> 0;
  {$ENDIF VCL}
  {$IFDEF VisualCLX}
  Result := False;
  {$ENDIF VisualCLX}
end;

type
  TControlAccessProtected = class(TControl);
{$IFDEF VisualCLX}
  TWidgetControlAccessProtected = class(TWidgetControl);
  TCustomControlAccessProtected = class(TCustomControl);
  TCustomEditAccessProtected = class(TCustomEdit);
  TCustomMaskEditAccessProtected = class(TCustomMaskEdit);

procedure WidgetControl_Painting(Instance: TWidgetControl; Canvas: TCanvas;
  EventRegion: QRegionH);
var
  HasBackground: Boolean;
  Pixmap: QPixmapH;
  OriginalPainter: QPainterH;
  Intf: IJvWinControlEvents;
  IsDoubleBuffered: Boolean;
  R: TRect;
begin
  if (csDestroying in Instance.ComponentState) or not Assigned(Instance.Parent) then
    Exit;

  R := Rect(0, 0, 0, 0);
  QRegion_boundingRect(EventRegion, @R);
  if IsRectEmpty(R) then
    exit;

  Instance.GetInterface(IJvWinControlEvents, Intf);
  IsDoubleBuffered := Intf.GetDoubleBuffered;
  Pixmap := nil;
  OriginalPainter := nil;

  with TWidgetControlAccessProtected(Instance) do
  begin

    TControlCanvas(Canvas).StartPaint;

    if IsDoubleBuffered then
    begin
      Pixmap := QPixmap_create(Instance.Width, Instance.Height, -1, QPixmapOptimization_DefaultOptim);
      // fill with parent's background if the control has a parent
      if Instance.Parent <> nil then
        QPixmap_fill(Pixmap, Instance.Parent.Handle, QWidget_x(Instance.Handle), QWidget_y(Instance.Handle));
      OriginalPainter := Canvas.Handle;
      Canvas.Handle := QPainter_create(Pixmap);
      TControlCanvas(Canvas).StartPaint;
      QPainter_setClipRegion(Canvas.Handle, EventRegion);
      QPainter_setClipping(Canvas.Handle, True);
    end;
    try
      Canvas.Brush.Assign(Brush);
      Canvas.Font.Assign(Font);
      QPainter_setFont(Canvas.Handle, Canvas.Font.Handle);
      QPainter_setPen(Canvas.Handle, Canvas.Font.FontPen);
      QPainter_setBrush(Canvas.Handle, Canvas.Brush.Handle);

      HasBackground := (Instance as IJvWinControlEvents).DoPaintBackground(Canvas, 0);

      if IsDoubleBuffered then
      begin
        if not HasBackground then
        begin
          // fill with control's background
          if (QWidget_backgroundPixmap(Handle) <> nil) and
             not QPixmap_isNull(QWidget_backgroundPixmap(Handle)) then
            QPixmap_fill(Pixmap, Handle, 0, 0)
          else
          begin
            Canvas.FillRect(Rect( 0, 0, Width, Height));
          end;
        end;
      end;
      if Instance is TCustomForm then
        // TCustomForm calls Paint in it's EventFilter
      else
      if Instance is TCustomControl then
        TCustomControlAccessProtected(Instance).Paint
      else
        Intf.Paint;
    finally
      if Pixmap <> nil then
      begin
        TControlCanvas(Canvas).StopPaint;
        QPainter_destroy(Canvas.Handle);
        Canvas.Handle := OriginalPainter;
        bitBlt(QPainter_device(Canvas.Handle), R.Left, R.Top,
          Pixmap, R.Left, R.Top, R.Right - R.Left, R.Bottom - R.Top,
          RasterOp_CopyROP, True);
        QPixmap_destroy(Pixmap);
      end;
      TControlCanvas(Canvas).StopPaint;
    end;
  end;
end;

procedure WidgetControl_DefaultPaint(Instance: TWidgetControl; Canvas: TCanvas);
var
  PaintDevice: QPaintDeviceH;
  IsActive: Boolean;
  Painting: procedure(Instance: TWidgetControl; Sender: QObjectH; EventRegion: QRegionH);
  Painter: QPainterH;
begin
  if not (csDestroying in Instance.ComponentState) and
     (not Supports(Instance, IJvCustomControlEvents)) then
       { TCustomControls do not have a Qt paint method. }
  begin
   // Canvas.StopPaint uses a counter, but we must garantee the Stop.
    PaintDevice := nil;
    Painter := Canvas.Handle;
    IsActive := QPainter_isActive(Painter);
    if IsActive then
    begin
      PaintDevice := QPainter_device(Painter);
      QPainter_end(Painter);
    end;
    try
      Painting := @TWidgetControlAccessProtected.Painting;
     // default painting
      Painting(Instance, Instance.Handle, QPainter_clipRegion(Painter));
    finally
      // restore
      if IsActive then
        QPainter_begin(Painter, PaintDevice); // restart
    end;
  end;
end;

function TWidgetControl_NeedKey(Instance: TWidgetControl; Key: Integer;
  Shift: TShiftState; const KeyText: WideString; InheritedValue: Boolean): Boolean;

  function IsTabKey: Boolean;
  begin
    Result := (Key = Key_Tab) or (Key = Key_BackTab);
  end;

  function IsArrowKey: Boolean;
  begin
    Result := (Key = Key_Left) or (Key = Key_Right) or (Key = Key_Down) or (Key = Key_Up);
  end;

var
  DlgCodes: TDlgCodes;
  Value: TInputKeys;
begin
  Result := InheritedValue;
  Value := TWidgetControlAccessProtected(Instance).InputKeys;

  DlgCodes := [dcNative];
  if ikAll in Value then
    Include(DlgCodes, dcWantAllKeys);
  if ikArrows in Value then
    Include(DlgCodes, dcWantArrows);
  if ikTabs in Value then
    Include(DlgCodes, dcWantTab);
  if ikChars in Value then
    Include(DlgCodes, dcWantChars);

  (Instance as IJvWinControlEvents).DoGetDlgCode(DlgCodes);

  if not (dcNative in DlgCodes) then
  begin
    Result := False;
    if dcWantAllKeys in DlgCodes then
      Result := True;
    if (not Result) and (dcWantTab in DlgCodes) then
      Result := IsTabKey;
    if (not Result) and (dcWantArrows in DlgCodes) then
      Result := IsArrowKey;
    if (not Result) and (dcWantChars in DlgCodes) then
      Result := ((Shift * [ssCtrl, ssAlt] = []) and
        ((Hi(Word(Key)) = 0) or (Length(KeyText) > 0))) and
        not (IsTabKey or IsArrowKey);
  end;
end;

procedure TWidgetControl_ColorChanged(Instance: TWidgetControl);
var
  TC: QColorH;
  Intf: IJvWinControlEvents;
begin
  with TWidgetControlAccessProtected(Instance) do
  begin
    HandleNeeded;
    Instance.GetInterface(IJvWinControlEvents, Intf);
    if Bitmap.Empty then
    begin
      Palette.Color := Brush.Color;
      if not Intf.GetDoubleBuffered then
      begin
        TC := QColor(Color);
        QWidget_setBackgroundColor(Handle, TC);
        QColor_destroy(TC);
      end;
    end;
    NotifyControls(CM_PARENTCOLORCHANGED);
    Invalidate;
  end;
end;

{$IFDEF COMPILER6}

// redirect Kylix 3 / Delphi 7 function names to Delphi 6 available function
{$IF not declared(PatchedVCLX)}
type
  QClxLineEditH = QLineEditH;

procedure QClxLineEdit_copy(handle: QLineEditH); cdecl; external QtIntf name QtNamePrefix + 'QLineEdit_copy';
procedure QClxLineEdit_cut(handle: QLineEditH); cdecl; external QtIntf name QtNamePrefix + 'QLineEdit_cut';
procedure QClxLineEdit_insert(handle: QLineEditH; p1: PWideString); cdecl; external QtIntf name QtNamePrefix + 'QLineEdit_insert';
{$IFEND}

procedure QClxLineEdit_undo(handle: QLineEditH);
var
  W: WideString;
  Event: QKeyEventH;
begin
  W := 'Z';
  Event := QKeyEvent_create(QEventType_KeyPress, KEY_Z, Ord('Z'),
    Integer(ButtonState_ControlButton), @W, False, 1);
  try
    QApplication_sendEvent(handle, Event);
  finally
    QKeyEvent_destroy(Event);
  end;
end;

{$ENDIF COMPILER6}

{$ENDIF VisualCLX}

procedure TCustomEdit_Undo(Instance: TWinControl);
begin
  {$IFDEF VCL}
  InheritMsg(Instance, WM_UNDO);
  {$ENDIF VCL}
  {$IFDEF VisualCLX}
  if Instance is TCustomMemo then
    QMultiLineEdit_undo(QMultiLineEditH(Instance.Handle))
  else
  if Instance is TCustomEdit then
    QClxLineEdit_undo(QClxLineEditH(Instance.Handle));
  {$ENDIF VisualCLX}
end;

procedure TCustomEdit_Copy(Instance: TWinControl);
begin
  {$IFDEF VCL}
  InheritMsg(Instance, WM_COPY);
  {$ENDIF VCL}
  {$IFDEF VisualCLX}
  if Instance is TCustomMemo then
    QMultiLineEdit_copy(QMultiLineEditH(Instance.Handle))
  else
  if Instance is TCustomEdit then
    QClxLineEdit_copy(QClxLineEditH(Instance.Handle));
  {$ENDIF VisualCLX}
end;

procedure TCustomEdit_Cut(Instance: TWinControl);
begin
  {$IFDEF VCL}
  InheritMsg(Instance, WM_CUT);
  {$ENDIF VCL}
  {$IFDEF VisualCLX}
  if Instance is TCustomMemo then
    QMultiLineEdit_cut(QMultiLineEditH(Instance.Handle))
  else
  if Instance is TCustomMaskEdit then
  begin
    if not (TCustomMaskEdit(Instance).IsMasked) then  // CutToClipboard would call "inherited"
      QClxLineEdit_cut(QClxLineEditH(Instance.Handle))
    else
      TCustomMaskEdit(Instance).CutToClipboard;
  end
  else
  if Instance is TCustomEdit then
    QClxLineEdit_cut(QClxLineEditH(Instance.Handle));
  {$ENDIF VisualCLX}
end;

procedure TCustomEdit_Paste(Instance: TWinControl);
  {$IFDEF VisualCLX}
  procedure LineEditPaste;
  var
    WValue: WideString;
  begin
    WValue := Clipboard.AsText;
    case TCustomEditAccessProtected(Instance).CharCase of
      ecUpperCase:
        WValue := WideUpperCase(WValue);
      ecLowerCase:
        WValue := WideLowerCase(WValue);
    end;
    QClxLineEdit_insert(QClxLineEditH(Instance.Handle), PWideString(@WValue));
    QClxLineEdit_resetSelection(QClxLineEditH(Instance.Handle));
  end;
  {$ENDIF VisualCLX}
begin
  {$IFDEF VCL}
  InheritMsg(Instance, WM_PASTE);
  {$ENDIF VCL}
  {$IFDEF VisualCLX}
  if Instance is TCustomMemo then
    QMultiLineEdit_paste(QMultiLineEditH(Instance.Handle))
  else
  if Instance is TCustomMaskEdit then
  begin
    if not TCustomMaskEdit(Instance).IsMasked or
       TCustomMaskEditAccessProtected(Instance).ReadOnly then  // PasteFromClipboard would call "inherited"
      QClxLineEdit_cut(QClxLineEditH(Instance.Handle))
    else
      TCustomMaskEdit(Instance).CutToClipboard;
  end
  else
  if Instance is TCustomEdit then
    LineEditPaste;
  {$ENDIF VisualCLX}
end;

// *****************************************************************************

{$IFDEF VCL}
procedure TJvExControl.Dispatch(var Msg);
asm
    JMP   DispatchMsg
end;

procedure TJvExControl.VisibleChanged;
asm
    MOV  EDX, CM_VISIBLECHANGED
    JMP  InheritMsg
end;

procedure TJvExControl.EnabledChanged;
asm
    MOV  EDX, CM_ENABLEDCHANGED
    JMP  InheritMsg
end;

procedure TJvExControl.TextChanged;
asm
    MOV  EDX, CM_TEXTCHANGED
    JMP  InheritMsg
end;

procedure TJvExControl.FontChanged;
asm
    MOV  EDX, CM_FONTCHANGED
    JMP  InheritMsg
end;

procedure TJvExControl.ColorChanged;
asm
    MOV  EDX, CM_COLORCHANGED
    JMP  InheritMsg
end;

procedure TJvExControl.ParentFontChanged;
asm
    MOV  EDX, CM_PARENTFONTCHANGED
    JMP  InheritMsg
end;

procedure TJvExControl.ParentShowHintChanged;
asm
    MOV  EDX, CM_PARENTSHOWHINTCHANGED
    JMP  InheritMsg
end;

function TJvExControl.WantKey(Key: Integer; Shift: TShiftState;
  const KeyText: WideString): Boolean;
begin
  Result := InheritMsgEx(Self, CM_DIALOGCHAR, Word(Key), ShiftStateToKeyData(Shift)) <> 0;
end;

function TJvExControl.HintShow(var HintInfo: THintInfo): Boolean;
begin
  Result := InheritMsgEx(Self, CM_HINTSHOW, 0, Integer(@HintInfo)) <> 0;
end;

function TJvExControl.HitTest(X, Y: Integer): Boolean;
begin
  Result := InheritMsgEx(Self, CM_HITTEST, 0, Integer(PointToSmallPoint(Point(X, Y)))) <> 0;
end;

procedure TJvExControl.MouseEnter(Control: TControl);
begin
  Control_MouseEnter(Self, Control, FMouseOver, FSavedHintColor, FHintColor,
    FOnMouseEnter);
end;

procedure TJvExControl.MouseLeave(Control: TControl);
begin
  Control_MouseLeave(Self, Control, FMouseOver, FSavedHintColor, FOnMouseLeave);
end;

procedure TJvExControl.ParentColorChanged;
begin
  InheritMsg(Self, CM_PARENTCOLORCHANGED);
  if Assigned(FOnParentColorChanged) then
    FOnParentColorChanged(Self);
end;

{$IFNDEF HASAUTOSIZE}
 {$IFNDEF COMPILER6_UP}
procedure TJvExControl.SetAutoSize(Value: Boolean);
begin
  TOpenControl_SetAutoSize(Self, Value);
end;
 {$ENDIF !COMPILER6_UP}
{$ENDIF !HASAUTOSIZE}
{$ENDIF VCL}
{$IFDEF VisualCLX}
procedure TJvExControl.MouseEnter(Control: TControl);
begin
  Control_MouseEnter(Self, Control, FMouseOver, FSavedHintColor, FHintColor);
  inherited MouseEnter(Control);
  {$IF not declared(PatchedVCLX)}
  if Assigned(FOnMouseEnter) then
    FOnMouseEnter(Self);
  {$IFEND}
end;

procedure TJvExControl.MouseLeave(Control: TControl);
begin
  Control_MouseLeave(Self, Control, FMouseOver, FSavedHintColor);
  inherited MouseLeave(Control);
  {$IF not declared(PatchedVCLX)}
  if Assigned(FOnMouseLeave) then
    FOnMouseLeave(Self);
  {$IFEND}
end;

procedure TJvExControl.ParentColorChanged;
begin
  inherited ParentColorChanged;
  if Assigned(FOnParentColorChanged) then
    FOnParentColorChanged(Self);
end;

function TJvExControl.Perform(Msg: Cardinal; WParam, LParam: Longint): Longint;
var
  Mesg: TMessage;
begin
  Mesg.Result := 0;
  if Self <> nil then
  begin
    Mesg.Msg := Msg;
    Mesg.WParam := WParam;
    Mesg.LParam := LParam;
    WindowProc(Mesg);
  end;
  Result := Mesg.Result;
end;

procedure TJvExControl.WndProc(var Msg: TMessage);
begin
  Dispatch(Msg);
end;

function TJvExControl.IsRightToLeft: Boolean;
begin
  Result := False;
end;
{$ENDIF VisualCLX}
procedure TJvExControl.CMFocusChanged(var Msg: TCMFocusChanged);
begin
  inherited;
  DoFocusChanged(Msg.Sender);
end;

procedure TJvExControl.DoFocusChanged(Control: TWinControl);
begin
end;

constructor TJvExControl.Create(AOwner: TComponent);
begin
  {$IFDEF VisualCLX}
  WindowProc := WndProc;
  {$IF declared(PatchedVCLX) and (PatchedVCLX > 3.3)}
  SetCopyRectMode(Self, cmVCL);
  {$IFEND}
  {$ENDIF VisualCLX}
  inherited Create(AOwner);
  FHintColor := clInfoBk;
  
end;

destructor TJvExControl.Destroy;
begin
  
  inherited Destroy;
end;
{$IFDEF VCL}
procedure TJvExWinControl.Dispatch(var Msg);
asm
    JMP   DispatchMsg
end;

procedure TJvExWinControl.VisibleChanged;
asm
    MOV  EDX, CM_VISIBLECHANGED
    JMP  InheritMsg
end;

procedure TJvExWinControl.EnabledChanged;
asm
    MOV  EDX, CM_ENABLEDCHANGED
    JMP  InheritMsg
end;

procedure TJvExWinControl.TextChanged;
asm
    MOV  EDX, CM_TEXTCHANGED
    JMP  InheritMsg
end;

procedure TJvExWinControl.FontChanged;
asm
    MOV  EDX, CM_FONTCHANGED
    JMP  InheritMsg
end;

procedure TJvExWinControl.ColorChanged;
asm
    MOV  EDX, CM_COLORCHANGED
    JMP  InheritMsg
end;

procedure TJvExWinControl.ParentFontChanged;
asm
    MOV  EDX, CM_PARENTFONTCHANGED
    JMP  InheritMsg
end;

procedure TJvExWinControl.ParentShowHintChanged;
asm
    MOV  EDX, CM_PARENTSHOWHINTCHANGED
    JMP  InheritMsg
end;

function TJvExWinControl.WantKey(Key: Integer; Shift: TShiftState;
  const KeyText: WideString): Boolean;
begin
  Result := InheritMsgEx(Self, CM_DIALOGCHAR, Word(Key), ShiftStateToKeyData(Shift)) <> 0;
end;

function TJvExWinControl.HintShow(var HintInfo: THintInfo): Boolean;
begin
  Result := InheritMsgEx(Self, CM_HINTSHOW, 0, Integer(@HintInfo)) <> 0;
end;

function TJvExWinControl.HitTest(X, Y: Integer): Boolean;
begin
  Result := InheritMsgEx(Self, CM_HITTEST, 0, Integer(PointToSmallPoint(Point(X, Y)))) <> 0;
end;

procedure TJvExWinControl.MouseEnter(Control: TControl);
begin
  Control_MouseEnter(Self, Control, FMouseOver, FSavedHintColor, FHintColor,
    FOnMouseEnter);
end;

procedure TJvExWinControl.MouseLeave(Control: TControl);
begin
  Control_MouseLeave(Self, Control, FMouseOver, FSavedHintColor, FOnMouseLeave);
end;

procedure TJvExWinControl.ParentColorChanged;
begin
  InheritMsg(Self, CM_PARENTCOLORCHANGED);
  if Assigned(FOnParentColorChanged) then
    FOnParentColorChanged(Self);
end;

{$IFNDEF HASAUTOSIZE}
 {$IFNDEF COMPILER6_UP}
procedure TJvExWinControl.SetAutoSize(Value: Boolean);
begin
  TOpenControl_SetAutoSize(Self, Value);
end;
 {$ENDIF !COMPILER6_UP}
{$ENDIF !HASAUTOSIZE}
procedure TJvExWinControl.CursorChanged;
asm
    MOV  EDX, CM_CURSORCHANGED
    JMP  InheritMsg
end;

procedure TJvExWinControl.ShowHintChanged;
asm
    MOV  EDX, CM_SHOWHINTCHANGED
    JMP  InheritMsg
end;

procedure TJvExWinControl.ShowingChanged;
asm
    MOV  EDX, CM_SHOWINGCHANGED
    JMP  InheritMsg
end;

procedure TJvExWinControl.ControlsListChanging(Control: TControl; Inserting: Boolean);
asm
    JMP   Control_ControlsListChanging
end;

procedure TJvExWinControl.ControlsListChanged(Control: TControl; Inserting: Boolean);
asm
    JMP   Control_ControlsListChanged
end;

{$IFDEF JVCLThemesEnabledD56}
function TJvExWinControl.GetParentBackground: Boolean;
asm
    JMP   JvThemes.GetParentBackground
end;

procedure TJvExWinControl.SetParentBackground(Value: Boolean);
asm
    JMP   JvThemes.SetParentBackground
end;
{$ENDIF JVCLThemesEnabledD56}

{$ENDIF VCL}
{$IFDEF VisualCLX}
procedure TJvExWinControl.MouseEnter(Control: TControl);
begin
  Control_MouseEnter(Self, Control, FMouseOver, FSavedHintColor, FHintColor);
  inherited MouseEnter(Control);
  {$IF not declared(PatchedVCLX)}
  if Assigned(FOnMouseEnter) then
    FOnMouseEnter(Self);
  {$IFEND}
end;

procedure TJvExWinControl.MouseLeave(Control: TControl);
begin
  Control_MouseLeave(Self, Control, FMouseOver, FSavedHintColor);
  inherited MouseLeave(Control);
  {$IF not declared(PatchedVCLX)}
  if Assigned(FOnMouseLeave) then
    FOnMouseLeave(Self);
  {$IFEND}
end;

procedure TJvExWinControl.ParentColorChanged;
begin
  inherited ParentColorChanged;
  if Assigned(FOnParentColorChanged) then
    FOnParentColorChanged(Self);
end;

function TJvExWinControl.Perform(Msg: Cardinal; WParam, LParam: Longint): Longint;
var
  Mesg: TMessage;
begin
  Mesg.Result := 0;
  if Self <> nil then
  begin
    Mesg.Msg := Msg;
    Mesg.WParam := WParam;
    Mesg.LParam := LParam;
    WindowProc(Mesg);
  end;
  Result := Mesg.Result;
end;

procedure TJvExWinControl.WndProc(var Msg: TMessage);
begin
  Dispatch(Msg);
end;

function TJvExWinControl.IsRightToLeft: Boolean;
begin
  Result := False;
end;
function TJvExWinControl.NeedKey(Key: Integer; Shift: TShiftState;
  const KeyText: WideString): Boolean;
begin
  Result := TWidgetControl_NeedKey(Self, Key, Shift, KeyText,
    inherited NeedKey(Key, Shift, KeyText));
end;

procedure TJvExWinControl.BoundsChanged;
begin
  inherited BoundsChanged;
  DoBoundsChanged;
end;

procedure TJvExWinControl.RecreateWnd;
begin
  RecreateWidget;
end;

procedure TJvExWinControl.CreateWidget;
begin
  CreateWnd;
end;

procedure TJvExWinControl.CreateWnd;
begin
  inherited CreateWidget;
end;
procedure TJvExWinControl.Painting(Sender: QObjectH; EventRegion: QRegionH);
begin
  WidgetControl_Painting(Self, Canvas, EventRegion);
end;

procedure TJvExWinControl.ColorChanged;
begin
  TWidgetControl_ColorChanged(Self);
end;

function TJvExWinControl.GetDoubleBuffered: Boolean;
begin
  Result := FDoubleBuffered;
end;

procedure TJvExWinControl.SetDoubleBuffered(Value: Boolean);
begin
  if Value <> FDoubleBuffered then
  begin
    if Value then
      QWidget_setBackgroundMode(Handle, QWidgetBackgroundMode_NoBackground)
    else
      QWidget_setBackgroundMode(Handle, QWidgetBackgroundMode_PaletteBackground);
    FDoubleBuffered := Value;
    if not (csCreating in ControlState) then
      Invalidate;
  end;
end;
{$ENDIF VisualCLX}
procedure TJvExWinControl.CMFocusChanged(var Msg: TCMFocusChanged);
begin
  inherited;
  DoFocusChanged(Msg.Sender);
end;

procedure TJvExWinControl.DoFocusChanged(Control: TWinControl);
begin
end;
procedure TJvExWinControl.DoBoundsChanged;
begin
end;

procedure TJvExWinControl.DoGetDlgCode(var Code: TDlgCodes);
begin
end;

procedure TJvExWinControl.DoSetFocus(FocusedWnd: HWND);
begin
end;

procedure TJvExWinControl.DoKillFocus(FocusedWnd: HWND);
begin
end;

function TJvExWinControl.DoPaintBackground(Canvas: TCanvas; Param: Integer): Boolean;
asm
  JMP   DefaultDoPaintBackground
end;
{$IFDEF VCL}
constructor TJvExWinControl.Create(AOwner: TComponent);
begin
  {$IFDEF VisualCLX}
  WindowProc := WndProc;
  {$IF declared(PatchedVCLX) and (PatchedVCLX > 3.3)}
  SetCopyRectMode(Self, cmVCL);
  {$IFEND}
  {$ENDIF VisualCLX}
  inherited Create(AOwner);
  FHintColor := clInfoBk;
  
end;

destructor TJvExWinControl.Destroy;
begin
  
  inherited Destroy;
end;
{$ENDIF VCL}
{$IFDEF VisualCLX}
constructor TJvExWinControl.Create(AOwner: TComponent);
begin
  WindowProc := WndProc;
  {$IF declared(PatchedVCLX) and (PatchedVCLX > 3.3)}
  SetCopyRectMode(Self, cmVCL);
  {$IFEND}
  inherited Create(AOwner);
  FCanvas := TControlCanvas.Create;
  TControlCanvas(FCanvas).Control := Self;
  
end;

destructor TJvExWinControl.Destroy;
begin
  
  FCanvas.Free;
  inherited Destroy;
end;

procedure TJvExWinControl.Paint;
begin
  WidgetControl_DefaultPaint(Self, Canvas);
end;

{$ENDIF VisualCLX}

{$IFDEF VCL}
procedure TJvExGraphicControl.Dispatch(var Msg);
asm
    JMP   DispatchMsg
end;

procedure TJvExGraphicControl.VisibleChanged;
asm
    MOV  EDX, CM_VISIBLECHANGED
    JMP  InheritMsg
end;

procedure TJvExGraphicControl.EnabledChanged;
asm
    MOV  EDX, CM_ENABLEDCHANGED
    JMP  InheritMsg
end;

procedure TJvExGraphicControl.TextChanged;
asm
    MOV  EDX, CM_TEXTCHANGED
    JMP  InheritMsg
end;

procedure TJvExGraphicControl.FontChanged;
asm
    MOV  EDX, CM_FONTCHANGED
    JMP  InheritMsg
end;

procedure TJvExGraphicControl.ColorChanged;
asm
    MOV  EDX, CM_COLORCHANGED
    JMP  InheritMsg
end;

procedure TJvExGraphicControl.ParentFontChanged;
asm
    MOV  EDX, CM_PARENTFONTCHANGED
    JMP  InheritMsg
end;

procedure TJvExGraphicControl.ParentShowHintChanged;
asm
    MOV  EDX, CM_PARENTSHOWHINTCHANGED
    JMP  InheritMsg
end;

function TJvExGraphicControl.WantKey(Key: Integer; Shift: TShiftState;
  const KeyText: WideString): Boolean;
begin
  Result := InheritMsgEx(Self, CM_DIALOGCHAR, Word(Key), ShiftStateToKeyData(Shift)) <> 0;
end;

function TJvExGraphicControl.HintShow(var HintInfo: THintInfo): Boolean;
begin
  Result := InheritMsgEx(Self, CM_HINTSHOW, 0, Integer(@HintInfo)) <> 0;
end;

function TJvExGraphicControl.HitTest(X, Y: Integer): Boolean;
begin
  Result := InheritMsgEx(Self, CM_HITTEST, 0, Integer(PointToSmallPoint(Point(X, Y)))) <> 0;
end;

procedure TJvExGraphicControl.MouseEnter(Control: TControl);
begin
  Control_MouseEnter(Self, Control, FMouseOver, FSavedHintColor, FHintColor,
    FOnMouseEnter);
end;

procedure TJvExGraphicControl.MouseLeave(Control: TControl);
begin
  Control_MouseLeave(Self, Control, FMouseOver, FSavedHintColor, FOnMouseLeave);
end;

procedure TJvExGraphicControl.ParentColorChanged;
begin
  InheritMsg(Self, CM_PARENTCOLORCHANGED);
  if Assigned(FOnParentColorChanged) then
    FOnParentColorChanged(Self);
end;

{$IFNDEF HASAUTOSIZE}
 {$IFNDEF COMPILER6_UP}
procedure TJvExGraphicControl.SetAutoSize(Value: Boolean);
begin
  TOpenControl_SetAutoSize(Self, Value);
end;
 {$ENDIF !COMPILER6_UP}
{$ENDIF !HASAUTOSIZE}
{$ENDIF VCL}
{$IFDEF VisualCLX}
procedure TJvExGraphicControl.MouseEnter(Control: TControl);
begin
  Control_MouseEnter(Self, Control, FMouseOver, FSavedHintColor, FHintColor);
  inherited MouseEnter(Control);
  {$IF not declared(PatchedVCLX)}
  if Assigned(FOnMouseEnter) then
    FOnMouseEnter(Self);
  {$IFEND}
end;

procedure TJvExGraphicControl.MouseLeave(Control: TControl);
begin
  Control_MouseLeave(Self, Control, FMouseOver, FSavedHintColor);
  inherited MouseLeave(Control);
  {$IF not declared(PatchedVCLX)}
  if Assigned(FOnMouseLeave) then
    FOnMouseLeave(Self);
  {$IFEND}
end;

procedure TJvExGraphicControl.ParentColorChanged;
begin
  inherited ParentColorChanged;
  if Assigned(FOnParentColorChanged) then
    FOnParentColorChanged(Self);
end;

function TJvExGraphicControl.Perform(Msg: Cardinal; WParam, LParam: Longint): Longint;
var
  Mesg: TMessage;
begin
  Mesg.Result := 0;
  if Self <> nil then
  begin
    Mesg.Msg := Msg;
    Mesg.WParam := WParam;
    Mesg.LParam := LParam;
    WindowProc(Mesg);
  end;
  Result := Mesg.Result;
end;

procedure TJvExGraphicControl.WndProc(var Msg: TMessage);
begin
  Dispatch(Msg);
end;

function TJvExGraphicControl.IsRightToLeft: Boolean;
begin
  Result := False;
end;
{$ENDIF VisualCLX}
procedure TJvExGraphicControl.CMFocusChanged(var Msg: TCMFocusChanged);
begin
  inherited;
  DoFocusChanged(Msg.Sender);
end;

procedure TJvExGraphicControl.DoFocusChanged(Control: TWinControl);
begin
end;

constructor TJvExGraphicControl.Create(AOwner: TComponent);
begin
  {$IFDEF VisualCLX}
  WindowProc := WndProc;
  {$IF declared(PatchedVCLX) and (PatchedVCLX > 3.3)}
  SetCopyRectMode(Self, cmVCL);
  {$IFEND}
  {$ENDIF VisualCLX}
  inherited Create(AOwner);
  FHintColor := clInfoBk;
  
end;

destructor TJvExGraphicControl.Destroy;
begin
  
  inherited Destroy;
end;
{$IFDEF VisualCLX}
function TJvExGraphicControl.GetText: TCaption;
begin
  Result := FText;
end;

procedure TJvExGraphicControl.SetText(const Value: TCaption);
begin
  if Value <> FText then
  begin
    FText := Value;
    TextChanged;
  end;
end;

procedure TJvExGraphicControl.PaintRequest;
begin
  if not Assigned(Parent) then
    Exit;
  Canvas.Start;
  try
    Canvas.Brush.Color := Color;
    Canvas.Brush.Style := bsSolid;
    Canvas.Font.Assign(Font);
    QPainter_setFont(Canvas.Handle, Canvas.Font.Handle);
    QPainter_setPen(Canvas.Handle, Canvas.Font.FontPen);
    QPainter_setBrush(Canvas.Handle, Canvas.Brush.Handle);
    inherited PaintRequest;
  finally
    Canvas.Stop;
  end;
end;
{$ENDIF VisualCLX}


{$IFDEF VCL}
procedure TJvExCustomControl.Dispatch(var Msg);
asm
    JMP   DispatchMsg
end;

procedure TJvExCustomControl.VisibleChanged;
asm
    MOV  EDX, CM_VISIBLECHANGED
    JMP  InheritMsg
end;

procedure TJvExCustomControl.EnabledChanged;
asm
    MOV  EDX, CM_ENABLEDCHANGED
    JMP  InheritMsg
end;

procedure TJvExCustomControl.TextChanged;
asm
    MOV  EDX, CM_TEXTCHANGED
    JMP  InheritMsg
end;

procedure TJvExCustomControl.FontChanged;
asm
    MOV  EDX, CM_FONTCHANGED
    JMP  InheritMsg
end;

procedure TJvExCustomControl.ColorChanged;
asm
    MOV  EDX, CM_COLORCHANGED
    JMP  InheritMsg
end;

procedure TJvExCustomControl.ParentFontChanged;
asm
    MOV  EDX, CM_PARENTFONTCHANGED
    JMP  InheritMsg
end;

procedure TJvExCustomControl.ParentShowHintChanged;
asm
    MOV  EDX, CM_PARENTSHOWHINTCHANGED
    JMP  InheritMsg
end;

function TJvExCustomControl.WantKey(Key: Integer; Shift: TShiftState;
  const KeyText: WideString): Boolean;
begin
  Result := InheritMsgEx(Self, CM_DIALOGCHAR, Word(Key), ShiftStateToKeyData(Shift)) <> 0;
end;

function TJvExCustomControl.HintShow(var HintInfo: THintInfo): Boolean;
begin
  Result := InheritMsgEx(Self, CM_HINTSHOW, 0, Integer(@HintInfo)) <> 0;
end;

function TJvExCustomControl.HitTest(X, Y: Integer): Boolean;
begin
  Result := InheritMsgEx(Self, CM_HITTEST, 0, Integer(PointToSmallPoint(Point(X, Y)))) <> 0;
end;

procedure TJvExCustomControl.MouseEnter(Control: TControl);
begin
  Control_MouseEnter(Self, Control, FMouseOver, FSavedHintColor, FHintColor,
    FOnMouseEnter);
end;

procedure TJvExCustomControl.MouseLeave(Control: TControl);
begin
  Control_MouseLeave(Self, Control, FMouseOver, FSavedHintColor, FOnMouseLeave);
end;

procedure TJvExCustomControl.ParentColorChanged;
begin
  InheritMsg(Self, CM_PARENTCOLORCHANGED);
  if Assigned(FOnParentColorChanged) then
    FOnParentColorChanged(Self);
end;

{$IFNDEF HASAUTOSIZE}
 {$IFNDEF COMPILER6_UP}
procedure TJvExCustomControl.SetAutoSize(Value: Boolean);
begin
  TOpenControl_SetAutoSize(Self, Value);
end;
 {$ENDIF !COMPILER6_UP}
{$ENDIF !HASAUTOSIZE}
procedure TJvExCustomControl.CursorChanged;
asm
    MOV  EDX, CM_CURSORCHANGED
    JMP  InheritMsg
end;

procedure TJvExCustomControl.ShowHintChanged;
asm
    MOV  EDX, CM_SHOWHINTCHANGED
    JMP  InheritMsg
end;

procedure TJvExCustomControl.ShowingChanged;
asm
    MOV  EDX, CM_SHOWINGCHANGED
    JMP  InheritMsg
end;

procedure TJvExCustomControl.ControlsListChanging(Control: TControl; Inserting: Boolean);
asm
    JMP   Control_ControlsListChanging
end;

procedure TJvExCustomControl.ControlsListChanged(Control: TControl; Inserting: Boolean);
asm
    JMP   Control_ControlsListChanged
end;

{$IFDEF JVCLThemesEnabledD56}
function TJvExCustomControl.GetParentBackground: Boolean;
asm
    JMP   JvThemes.GetParentBackground
end;

procedure TJvExCustomControl.SetParentBackground(Value: Boolean);
asm
    JMP   JvThemes.SetParentBackground
end;
{$ENDIF JVCLThemesEnabledD56}

{$ENDIF VCL}
{$IFDEF VisualCLX}
procedure TJvExCustomControl.MouseEnter(Control: TControl);
begin
  Control_MouseEnter(Self, Control, FMouseOver, FSavedHintColor, FHintColor);
  inherited MouseEnter(Control);
  {$IF not declared(PatchedVCLX)}
  if Assigned(FOnMouseEnter) then
    FOnMouseEnter(Self);
  {$IFEND}
end;

procedure TJvExCustomControl.MouseLeave(Control: TControl);
begin
  Control_MouseLeave(Self, Control, FMouseOver, FSavedHintColor);
  inherited MouseLeave(Control);
  {$IF not declared(PatchedVCLX)}
  if Assigned(FOnMouseLeave) then
    FOnMouseLeave(Self);
  {$IFEND}
end;

procedure TJvExCustomControl.ParentColorChanged;
begin
  inherited ParentColorChanged;
  if Assigned(FOnParentColorChanged) then
    FOnParentColorChanged(Self);
end;

function TJvExCustomControl.Perform(Msg: Cardinal; WParam, LParam: Longint): Longint;
var
  Mesg: TMessage;
begin
  Mesg.Result := 0;
  if Self <> nil then
  begin
    Mesg.Msg := Msg;
    Mesg.WParam := WParam;
    Mesg.LParam := LParam;
    WindowProc(Mesg);
  end;
  Result := Mesg.Result;
end;

procedure TJvExCustomControl.WndProc(var Msg: TMessage);
begin
  Dispatch(Msg);
end;

function TJvExCustomControl.IsRightToLeft: Boolean;
begin
  Result := False;
end;
function TJvExCustomControl.NeedKey(Key: Integer; Shift: TShiftState;
  const KeyText: WideString): Boolean;
begin
  Result := TWidgetControl_NeedKey(Self, Key, Shift, KeyText,
    inherited NeedKey(Key, Shift, KeyText));
end;

procedure TJvExCustomControl.BoundsChanged;
begin
  inherited BoundsChanged;
  DoBoundsChanged;
end;

procedure TJvExCustomControl.RecreateWnd;
begin
  RecreateWidget;
end;

procedure TJvExCustomControl.CreateWidget;
begin
  CreateWnd;
end;

procedure TJvExCustomControl.CreateWnd;
begin
  inherited CreateWidget;
end;
procedure TJvExCustomControl.Painting(Sender: QObjectH; EventRegion: QRegionH);
begin
  WidgetControl_Painting(Self, Canvas, EventRegion);
end;

procedure TJvExCustomControl.ColorChanged;
begin
  TWidgetControl_ColorChanged(Self);
end;

function TJvExCustomControl.GetDoubleBuffered: Boolean;
begin
  Result := FDoubleBuffered;
end;

procedure TJvExCustomControl.SetDoubleBuffered(Value: Boolean);
begin
  if Value <> FDoubleBuffered then
  begin
    if Value then
      QWidget_setBackgroundMode(Handle, QWidgetBackgroundMode_NoBackground)
    else
      QWidget_setBackgroundMode(Handle, QWidgetBackgroundMode_PaletteBackground);
    FDoubleBuffered := Value;
    if not (csCreating in ControlState) then
      Invalidate;
  end;
end;
{$ENDIF VisualCLX}
procedure TJvExCustomControl.CMFocusChanged(var Msg: TCMFocusChanged);
begin
  inherited;
  DoFocusChanged(Msg.Sender);
end;

procedure TJvExCustomControl.DoFocusChanged(Control: TWinControl);
begin
end;
procedure TJvExCustomControl.DoBoundsChanged;
begin
end;

procedure TJvExCustomControl.DoGetDlgCode(var Code: TDlgCodes);
begin
end;

procedure TJvExCustomControl.DoSetFocus(FocusedWnd: HWND);
begin
end;

procedure TJvExCustomControl.DoKillFocus(FocusedWnd: HWND);
begin
end;

function TJvExCustomControl.DoPaintBackground(Canvas: TCanvas; Param: Integer): Boolean;
asm
  JMP   DefaultDoPaintBackground
end;
{$IFDEF VCL}
constructor TJvExCustomControl.Create(AOwner: TComponent);
begin
  {$IFDEF VisualCLX}
  WindowProc := WndProc;
  {$IF declared(PatchedVCLX) and (PatchedVCLX > 3.3)}
  SetCopyRectMode(Self, cmVCL);
  {$IFEND}
  {$ENDIF VisualCLX}
  inherited Create(AOwner);
  FHintColor := clInfoBk;
  
end;

destructor TJvExCustomControl.Destroy;
begin
  
  inherited Destroy;
end;
{$ENDIF VCL}
{$IFDEF VisualCLX}
constructor TJvExCustomControl.Create(AOwner: TComponent);
begin
  WindowProc := WndProc;
  {$IF declared(PatchedVCLX) and (PatchedVCLX > 3.3)}
  SetCopyRectMode(Self, cmVCL);
  {$IFEND}
  inherited Create(AOwner);
  
  DoubleBuffered := True;
end;

destructor TJvExCustomControl.Destroy;
begin
  
  inherited Destroy;
end;
{$ENDIF VisualCLX}
{$IFDEF VCL}
procedure TJvExHintWindow.Dispatch(var Msg);
asm
    JMP   DispatchMsg
end;

procedure TJvExHintWindow.VisibleChanged;
asm
    MOV  EDX, CM_VISIBLECHANGED
    JMP  InheritMsg
end;

procedure TJvExHintWindow.EnabledChanged;
asm
    MOV  EDX, CM_ENABLEDCHANGED
    JMP  InheritMsg
end;

procedure TJvExHintWindow.TextChanged;
asm
    MOV  EDX, CM_TEXTCHANGED
    JMP  InheritMsg
end;

procedure TJvExHintWindow.FontChanged;
asm
    MOV  EDX, CM_FONTCHANGED
    JMP  InheritMsg
end;

procedure TJvExHintWindow.ColorChanged;
asm
    MOV  EDX, CM_COLORCHANGED
    JMP  InheritMsg
end;

procedure TJvExHintWindow.ParentFontChanged;
asm
    MOV  EDX, CM_PARENTFONTCHANGED
    JMP  InheritMsg
end;

procedure TJvExHintWindow.ParentShowHintChanged;
asm
    MOV  EDX, CM_PARENTSHOWHINTCHANGED
    JMP  InheritMsg
end;

function TJvExHintWindow.WantKey(Key: Integer; Shift: TShiftState;
  const KeyText: WideString): Boolean;
begin
  Result := InheritMsgEx(Self, CM_DIALOGCHAR, Word(Key), ShiftStateToKeyData(Shift)) <> 0;
end;

function TJvExHintWindow.HintShow(var HintInfo: THintInfo): Boolean;
begin
  Result := InheritMsgEx(Self, CM_HINTSHOW, 0, Integer(@HintInfo)) <> 0;
end;

function TJvExHintWindow.HitTest(X, Y: Integer): Boolean;
begin
  Result := InheritMsgEx(Self, CM_HITTEST, 0, Integer(PointToSmallPoint(Point(X, Y)))) <> 0;
end;

procedure TJvExHintWindow.MouseEnter(Control: TControl);
begin
  Control_MouseEnter(Self, Control, FMouseOver, FSavedHintColor, FHintColor,
    FOnMouseEnter);
end;

procedure TJvExHintWindow.MouseLeave(Control: TControl);
begin
  Control_MouseLeave(Self, Control, FMouseOver, FSavedHintColor, FOnMouseLeave);
end;

procedure TJvExHintWindow.ParentColorChanged;
begin
  InheritMsg(Self, CM_PARENTCOLORCHANGED);
  if Assigned(FOnParentColorChanged) then
    FOnParentColorChanged(Self);
end;

{$IFNDEF HASAUTOSIZE}
 {$IFNDEF COMPILER6_UP}
procedure TJvExHintWindow.SetAutoSize(Value: Boolean);
begin
  TOpenControl_SetAutoSize(Self, Value);
end;
 {$ENDIF !COMPILER6_UP}
{$ENDIF !HASAUTOSIZE}
procedure TJvExHintWindow.CursorChanged;
asm
    MOV  EDX, CM_CURSORCHANGED
    JMP  InheritMsg
end;

procedure TJvExHintWindow.ShowHintChanged;
asm
    MOV  EDX, CM_SHOWHINTCHANGED
    JMP  InheritMsg
end;

procedure TJvExHintWindow.ShowingChanged;
asm
    MOV  EDX, CM_SHOWINGCHANGED
    JMP  InheritMsg
end;

procedure TJvExHintWindow.ControlsListChanging(Control: TControl; Inserting: Boolean);
asm
    JMP   Control_ControlsListChanging
end;

procedure TJvExHintWindow.ControlsListChanged(Control: TControl; Inserting: Boolean);
asm
    JMP   Control_ControlsListChanged
end;

{$IFDEF JVCLThemesEnabledD56}
function TJvExHintWindow.GetParentBackground: Boolean;
asm
    JMP   JvThemes.GetParentBackground
end;

procedure TJvExHintWindow.SetParentBackground(Value: Boolean);
asm
    JMP   JvThemes.SetParentBackground
end;
{$ENDIF JVCLThemesEnabledD56}

{$ENDIF VCL}
{$IFDEF VisualCLX}
procedure TJvExHintWindow.MouseEnter(Control: TControl);
begin
  Control_MouseEnter(Self, Control, FMouseOver, FSavedHintColor, FHintColor);
  inherited MouseEnter(Control);
  {$IF not declared(PatchedVCLX)}
  if Assigned(FOnMouseEnter) then
    FOnMouseEnter(Self);
  {$IFEND}
end;

procedure TJvExHintWindow.MouseLeave(Control: TControl);
begin
  Control_MouseLeave(Self, Control, FMouseOver, FSavedHintColor);
  inherited MouseLeave(Control);
  {$IF not declared(PatchedVCLX)}
  if Assigned(FOnMouseLeave) then
    FOnMouseLeave(Self);
  {$IFEND}
end;

procedure TJvExHintWindow.ParentColorChanged;
begin
  inherited ParentColorChanged;
  if Assigned(FOnParentColorChanged) then
    FOnParentColorChanged(Self);
end;

function TJvExHintWindow.Perform(Msg: Cardinal; WParam, LParam: Longint): Longint;
var
  Mesg: TMessage;
begin
  Mesg.Result := 0;
  if Self <> nil then
  begin
    Mesg.Msg := Msg;
    Mesg.WParam := WParam;
    Mesg.LParam := LParam;
    WindowProc(Mesg);
  end;
  Result := Mesg.Result;
end;

procedure TJvExHintWindow.WndProc(var Msg: TMessage);
begin
  Dispatch(Msg);
end;

function TJvExHintWindow.IsRightToLeft: Boolean;
begin
  Result := False;
end;
function TJvExHintWindow.NeedKey(Key: Integer; Shift: TShiftState;
  const KeyText: WideString): Boolean;
begin
  Result := TWidgetControl_NeedKey(Self, Key, Shift, KeyText,
    inherited NeedKey(Key, Shift, KeyText));
end;

procedure TJvExHintWindow.BoundsChanged;
begin
  inherited BoundsChanged;
  DoBoundsChanged;
end;

procedure TJvExHintWindow.RecreateWnd;
begin
  RecreateWidget;
end;

procedure TJvExHintWindow.CreateWidget;
begin
  CreateWnd;
end;

procedure TJvExHintWindow.CreateWnd;
begin
  inherited CreateWidget;
end;
procedure TJvExHintWindow.Painting(Sender: QObjectH; EventRegion: QRegionH);
begin
  WidgetControl_Painting(Self, Canvas, EventRegion);
end;

procedure TJvExHintWindow.ColorChanged;
begin
  TWidgetControl_ColorChanged(Self);
end;

function TJvExHintWindow.GetDoubleBuffered: Boolean;
begin
  Result := FDoubleBuffered;
end;

procedure TJvExHintWindow.SetDoubleBuffered(Value: Boolean);
begin
  if Value <> FDoubleBuffered then
  begin
    if Value then
      QWidget_setBackgroundMode(Handle, QWidgetBackgroundMode_NoBackground)
    else
      QWidget_setBackgroundMode(Handle, QWidgetBackgroundMode_PaletteBackground);
    FDoubleBuffered := Value;
    if not (csCreating in ControlState) then
      Invalidate;
  end;
end;
{$ENDIF VisualCLX}
procedure TJvExHintWindow.CMFocusChanged(var Msg: TCMFocusChanged);
begin
  inherited;
  DoFocusChanged(Msg.Sender);
end;

procedure TJvExHintWindow.DoFocusChanged(Control: TWinControl);
begin
end;
procedure TJvExHintWindow.DoBoundsChanged;
begin
end;

procedure TJvExHintWindow.DoGetDlgCode(var Code: TDlgCodes);
begin
end;

procedure TJvExHintWindow.DoSetFocus(FocusedWnd: HWND);
begin
end;

procedure TJvExHintWindow.DoKillFocus(FocusedWnd: HWND);
begin
end;

function TJvExHintWindow.DoPaintBackground(Canvas: TCanvas; Param: Integer): Boolean;
asm
  JMP   DefaultDoPaintBackground
end;
{$IFDEF VCL}
constructor TJvExHintWindow.Create(AOwner: TComponent);
begin
  {$IFDEF VisualCLX}
  WindowProc := WndProc;
  {$IF declared(PatchedVCLX) and (PatchedVCLX > 3.3)}
  SetCopyRectMode(Self, cmVCL);
  {$IFEND}
  {$ENDIF VisualCLX}
  inherited Create(AOwner);
  FHintColor := clInfoBk;
  
end;

destructor TJvExHintWindow.Destroy;
begin
  
  inherited Destroy;
end;
{$ENDIF VCL}
{$IFDEF VisualCLX}
constructor TJvExHintWindow.Create(AOwner: TComponent);
begin
  WindowProc := WndProc;
  {$IF declared(PatchedVCLX) and (PatchedVCLX > 3.3)}
  SetCopyRectMode(Self, cmVCL);
  {$IFEND}
  inherited Create(AOwner);
  
  DoubleBuffered := True;
end;

destructor TJvExHintWindow.Destroy;
begin
  
  inherited Destroy;
end;
{$ENDIF VisualCLX}

// *****************************************************************************

type
  PBoolean = ^Boolean;
  PPointer = ^Pointer;

function ReadProtectedMemory(Address: Pointer; var Buffer; Count: Cardinal): Boolean;
var
  n: Cardinal;
begin
  Result := ReadProcessMemory(GetCurrentProcess, Address, @Buffer, Count, n);
  Result := Result and (n = Count);
end;

function WriteProtectedMemory(Address: Pointer; const Buffer; Count: Cardinal): Boolean;
var
  n: Cardinal;
begin
  Result := WriteProcessMemory(GetCurrentProcess, Address, @Buffer, Count, n);
  Result := Result and (n = Count);
end;

type
  TJumpCode = packed record
    Pop: Byte; // pop xxx
    Jmp: Byte; // jmp Offset
    Offset: Integer;
  end;

  TOrgCallCode = packed record
    Push: Byte; // push ebx/ebp
    InjectedCode: TJumpCode;
    Jmp: Byte; // jmp Offset
    Offset: Integer;
    Address: Pointer;
  end;

function GetRelocAddress(ProcAddress: Pointer): Pointer;
type
  TRelocationRec = packed record
    Jump: Word;
    Address: PPointer;
  end;
var
  Relocation: TRelocationRec;
  Data: Byte;
begin
  Result := ProcAddress;
 // the relocation table meight be protected
  if ReadProtectedMemory(ProcAddress, Data, SizeOf(Data)) then
  begin
    if Data = $FF then // ProcAddress is in a dll or package
      if ReadProtectedMemory(ProcAddress, Relocation, SizeOf(Relocation)) then
        Result := Relocation.Address^;
  end;
end;

function InstallProcHook(ProcAddress, HookProc, OrgCallProc: Pointer): Boolean;
var
  Code: TJumpCode;
  OrgCallCode: TOrgCallCode;
begin
  ProcAddress := GetRelocAddress(ProcAddress);
  Result := False;
  if Assigned(ProcAddress) and Assigned(HookProc) then
  begin
    if OrgCallProc <> nil then
    begin
      if ReadProtectedMemory(ProcAddress, OrgCallCode, SizeOf(OrgCallCode) - (1 + SizeOf(Integer))) then
      begin
        OrgCallCode.Jmp := $E9;
        OrgCallCode.Offset := (Integer(ProcAddress) + 1 + SizeOf(Code)) -
          Integer(OrgCallProc) -
          (SizeOf(OrgCallCode) - SizeOf(OrgCallCode.Address));
        OrgCallCode.Address := ProcAddress;

        WriteProtectedMemory(OrgCallProc, OrgCallCode, SizeOf(OrgCallCode));
        FlushInstructionCache(GetCurrentProcess, OrgCallProc, SizeOf(OrgCallCode));
      end;
    end;

    if PByte(ProcAddress)^ = $53 then // push ebx
      Code.Pop := $5B // pop ebx
    else
    if PByte(ProcAddress)^ = $55 then // push ebp
      Code.Pop := $5D // pop ebp
    else
      Exit;
    Code.Jmp := $E9;
    Code.Offset := Integer(HookProc) - (Integer(ProcAddress) + 1) - SizeOf(Code);

   { The strange thing is that something overwrites the $e9 with a "PUSH xxx" }
    if WriteProtectedMemory(Pointer(Cardinal(ProcAddress) + 1), Code,
         SizeOf(Code)) then
    begin
      FlushInstructionCache(GetCurrentProcess, ProcAddress, SizeOf(Code));
      Result := True;
    end;
  end;
end;

function UninstallProcHook(OrgCallProc: Pointer): Boolean;
var
  OrgCallCode: TOrgCallCode;
  ProcAddress: Pointer;
begin
  Result := False;
  if Assigned(OrgCallProc) then
  begin
    if OrgCallProc <> nil then
    begin
      if ReadProtectedMemory(OrgCallProc, OrgCallCode, SizeOf(OrgCallCode)) then
      begin
        ProcAddress := OrgCallCode.Address;

        Result := WriteProtectedMemory(ProcAddress, OrgCallCode, 1 + SizeOf(TJumpCode));
        FlushInstructionCache(GetCurrentProcess, ProcAddress, SizeOf(OrgCallCode));
      end;
    end;
  end;
end;

{$IFDEF COMPILER5}
var
  AutoSizeOffset: Cardinal;
  TControl_SetAutoSize: Pointer;

procedure OrgSetAutoSize(Instance: TControl; Value: Boolean);
asm
  dd    0, 0, 0, 0  // 16 Bytes
end;

procedure TOpenControl_SetAutoSize(Instance: TControl; Value: Boolean);
begin
  with TControlAccessProtected(Instance) do
  begin
    if AutoSize <> Value then
    begin
      PBoolean(Cardinal(Instance) + AutoSizeOffset)^ := Value;
      if Value then
        AdjustSize;
    end;
  end;
  // same as OrgSetAutoSize(Instance, Value); but secure
end;

procedure SetAutoSizeHook(Instance: TControl; Value: Boolean);
var
  IntfControl: IJvControlEvents;
begin
  if Instance.GetInterface(IJvControlEvents, IntfControl) then
    IntfControl.SetAutoSize(Value)
  else
    TOpenControl_SetAutoSize(Instance, Value);
end;

{$OPTIMIZATION ON} // be sure to have optimization activated
function GetCode(Instance: TControlAccessProtected): Boolean; register;
begin
  { generated code:
      8A40xx       mov al,[eax+Byte(Offset)]
  }
  Result := Instance.AutoSize;
end;

procedure SetCode(Instance: TControlAccessProtected); register;
begin
  { generated code:
      B201         mov dl,$01
      E8xxxxxxxx   call TControl.SetAutoSize
  }
  Instance.AutoSize := True;
end;

type
  PGetCodeRec = ^TGetCodeRec;
  TGetCodeRec = packed record
    Sign: Word; // $408a   bytes swapped
    Offset: Byte;
  end;

type
  PSetCodeRec = ^TSetCodeRec;
  TSetCodeRec = packed record
    Sign1: Word; // $01b2  bytes swapped
    Sign2: Byte; // $e8
    Offset: Integer;
  end;

const
  GetCodeSign = $408a;
  SetCodeSign1 = $01b2;
  SetCodeSign2 = $e8;

procedure InitHookVars;
var
  PGetCode: PGetCodeRec;
  PSetCode: PSetCodeRec;
begin
  TControl_SetAutoSize := nil;
  AutoSizeOffset := 0;

  PGetCode := @GetCode;
  PSetCode := @SetCode;

  if (PGetCode^.Sign = GetCodeSign) and
     (PSetCode^.Sign1 = SetCodeSign1) and (PSetCode^.Sign2 = SetCodeSign2) then
  begin
    AutoSizeOffset := PGetCode^.Offset;
    TControl_SetAutoSize := GetRelocAddress(
      Pointer(Integer(@SetCode) + SizeOf(TSetCodeRec) + PSetCode^.Offset));
  end;
end;

initialization
  InitHookVars;
  InstallProcHook(TControl_SetAutoSize, @SetAutoSizeHook, @OrgSetAutoSize);

finalization
  UninstallProcHook(@OrgSetAutoSize);

{$ENDIF COMPILER5}

{$IFDEF VisualCLX}

// Handles DoSetFocus and DoKillFocus

function AppEventFilter(App: TApplication; Sender: QObjectH; Event: QEventH): Boolean; cdecl;
var
  Control: TWidgetControl;
  Intf: IJvWinControlEvents;
  Wnd: HWND;
begin
  Result := False; // let the default event handler handle this event
  try
    case QEvent_type(Event) of
      QEventType_FocusIn, QEventType_FocusOut:
        begin
          Control := FindControl(QWidgetH(Sender));
          if (Control <> nil) and Supports(Control, IJvWinControlEvents, Intf) then
          begin
            if Screen.ActiveControl <> nil then
              Wnd := Screen.ActiveControl.Handle
            else
              Wnd := HWND(0);
            if QEvent_type(Event) = QEventType_FocusIn then
              Intf.DoSetFocus(Wnd)
            else
              Intf.DoKillFocus(Wnd);
          end;
        end;
    end;
  except
    on E: Exception do
    begin
      Application.ShowException(E);
      Result := False;
    end;
  end;
end;

var
  AppEventFilterHook: QObject_hookH = nil;

procedure InstallAppEventFilterHook;
var
  Method: TMethod;
begin
  if AppEventFilterHook = nil then
  begin
    Method.Code := @AppEventFilter;
    Method.Data := Application;
    AppEventFilterHook := QObject_hook_create(Application.Handle);
    Qt_hook_hook_events(AppEventFilterHook, Method);
  end;
end;

procedure UninstallAppEventFilterHook;
begin
  if Assigned(AppEventFilterHook) then
    QObject_hook_destroy(AppEventFilterHook);
end;


function CallSetFocusedControl(Instance: TCustomForm; Control: TWidgetControl): Boolean;
asm
  dd    0, 0, 0, 0  // 16 Bytes
end;

function SetFocusedControlHook(Instance: TCustomForm; Control: TWidgetControl): Boolean;
var
  Msg: TCMFocusChanged;
begin
  if csFocusing in Instance.ControlState then
    Result := CallSetFocusedControl(Instance, Control)
  else
  begin
    Result := CallSetFocusedControl(Instance, Control);
    if Result then
    begin
      Instance.ControlState := Instance.ControlState + [csFocusing]; // lock
      try
        Msg.Msg := CM_FOCUSCHANGED;
        Msg.Unused := 0;
        Msg.Sender := Control;
        Msg.Result := 0;
        Instance.Broadcast(Msg);
      finally
        Instance.ControlState := Instance.ControlState - [csFocusing];
      end;
    end;
  end;
end;

procedure CutToClipboardHook(Instance: TWidgetControl);
var
  Intf: IJvEditControlEvents;
begin
  if Supports(Instance, IJvEditControlEvents, Intf) then
    Intf.DoClipboardCut
  else
    TCustomEdit_Cut(Instance);
end;

procedure CopyToClipboardHook(Instance: TWidgetControl);
var
  Intf: IJvEditControlEvents;
begin
  if Supports(Instance, IJvEditControlEvents, Intf) then
    Intf.DoClipboardCopy
  else
    TCustomEdit_Copy(Instance);
end;

procedure PasteFromClipboardHook(Instance: TWidgetControl);
var
  Intf: IJvEditControlEvents;
begin
  if Supports(Instance, IJvEditControlEvents, Intf) then
    Intf.DoClipboardPaste
  else
    TCustomEdit_Paste(Instance);
end;

procedure UndoHook(Instance: TWidgetControl);
var
  Intf: IJvEditControlEvents;
begin
  if Supports(Instance, IJvEditControlEvents, Intf) then
    Intf.DoUndo
  else
    TCustomEdit_Undo(Instance);
end;

var
  CallCutToClipboard, CallPasteFromClipboard,
    CallCopyToClipboard, CallUndo: TOrgCallCode;

initialization
  InstallAppEventFilterHook;
  InstallProcHook(@TCustomForm.SetFocusedControl, @SetFocusedControlHook,
    @CallSetFocusedControl);

  InstallProcHook(@TCustomEdit.CutToClipboard, @CutToClipboardHook,
    @CallCutToClipboard);
  InstallProcHook(@TCustomEdit.CopyToClipboard, @CopyToClipboardHook,
    @CallCopyToClipboard);
  InstallProcHook(@TCustomEdit.PasteFromClipboard, @PasteFromClipboardHook,
    @CallPasteFromClipboard);
  {$IFDEF COMPILER7}
  InstallProcHook(@TCustomEdit.Undo, @UndoHook,
    @CallUndo);
  {$ELSE}
  {$IF declared(PatchedVCLX)}
  InstallProcHook(@TCustomEdit.Undo, @UndoHook,
    @CallUndo);
  {$IFEND}
  {$ENDIF COMPILER7}

finalization
  UninstallProcHook(@CallCutToClipboard);
  UninstallProcHook(@CallCopyToClipboard);
  UninstallProcHook(@CallPasteFromClipboard);
  {$IFDEF COMPILER7}
  UninstallProcHook(@CallUndo);
  {$ELSE}
  {$IF declared(PatchedVCLX)}
  UninstallProcHook(@CallUndo);
  {$IFEND}
  {$ENDIF COMPILER7}

  UninstallProcHook(@CallSetFocusedControl);
  UninstallAppEventFilterHook;

{$ENDIF VisualCLX}

end.

