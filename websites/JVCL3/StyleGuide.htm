<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0048) -->
  <title>Object Pascal Style Guide original by Charles Calvert</title>
  <meta http-equiv="Content-Type"
 content="text/html; charset=windows-1252">
  <link rel="STYLESHEET" href="styles/default.css" type="text/css">
</head>
<body>
<h1> Object Pascal Style Guide</h1>
<address> <br>
Original by Charles Calvert</address>
<pre>&nbsp;</pre>
<p>This article documents a standard style for formatting Delphi code
which is to be included in the JEDI Visual Component Library (JVCL).
This document is a modified/annotated version of the article originally
written by Charles Calvert (with his permission to do so). The original
article can be obtained from the Codegear <a
 href="http://edn.embarcadero.com/article/10280">Community
site</a>. As documented elsewhere, it's not necessary for you to format
your code according to the rules of this document before submitting it
to Project JEDI, although that would be great. Instead the reformatting
is done by the JVCL unit owners where necessary. We accept feedback in
the form of corrections or suggestions. Send your communications to <a
 href="mailto:jvcl@delphi-jedi.org?subject=StyleGuide">the JVCL team</a>
or <a href="mailto:ccalvert@codegear.com?subject=StyleGuide">Charlie
Calvert</a>. Note that with a few exceptions this document does not
include coding guideliness, only formatting guideliness. A separate
document for coding guideliness is in the making.</p>
<p>&nbsp;</p>
<p>This article documents a standard style for formatting Delphi code.
It is based on the conventions developed by the Delphi team.</p>
<p>Object Pascal is a beautifully designed language. One of its great
virtues is its readability. These standards are designed to enhance
that readability of Object Pascal code. When developers follow the
simple conventions laid out in this guide, they will be promoting
standards that benefit all Delphi developers by using a uniform style
that is easy to read. Efforts to enforce these standards will increase
the value of a developer's source code, particularly during maintenance
and debugging cycles.</p>
<p>&nbsp;</p>
<p>It goes without saying that these are conventions based primarily on
matters of taste. Though we believe in, and admire the style promoted
in these pages, we support them not necessarily because we believe they
are right and others are wrong, but because we believe in the efficacy
of having a standard which most developers follow. The human mind
adapts to standards, and finds ways to quickly recognize familiar
patterns, thereby assimilating meaning quickly and effortlessly. It is
the desire to create a standard that will make reading code as simple
as possible for the largest number of people that is behind this
effort. If at first our guidelines seem strange to you, we ask you to
try them for a while, and then we are sure you will grow used to them
over time.</p>
<p>&nbsp;</p>
<p>Do not post this specification on other web sites. Instead, simply
link to either this version of the document or the original one on
Charlie's website.</p>
<p>&nbsp;</p>
<h2>Contents</h2>
<p>&nbsp;</p>
<p>1.0 <a href="#1.0">Introduction</a></p>
<dl>
  <dd>1.1 <a href="#1.1">Background</a> </dd>
  <dd>1.2 <a href="http://delphi-jedi.org/d%22#1.2%22">Acknowledgments</a>
  </dd>
</dl>
<p>2.0 <a href="#2.0">Source Files</a></p>
<dl>
  <dd>2.1 <a href="#2.1">Source-File Naming</a> </dd>
  <dd>2.2 <a href="#2.2">Source-File Organization</a>
    <dl>
      <dd>2.2.1 <a href="#2.2.2">unit declaration</a> </dd>
      <dd>2.2.2 <a href="#2.2.3">uses declarations</a> </dd>
      <dd>2.2.3 <a href="#2.2.4">class/interface declarations</a> </dd>
    </dl>
  </dd>
</dl>
<p>3.0 <a href="#3.0">Naming Conventions</a></p>
<dl>
  <dd>3.1 <a href="#3.1">Unit Naming</a> </dd>
  <dd>3.2 <a href="#3.2">Class/Interface Naming</a> </dd>
  <dd>3.3 <a href="#3.3">Field Naming</a> </dd>
  <dd>3.4 <a href="#3.4">Method Naming</a> </dd>
  <dd>3.5 <a href="#3.5">Local Variable Naming</a> </dd>
  <dd>3.6 <a href="#3.6">Reserved Words</a> </dd>
  <dd>3.7 <a href="#3.6">Type Declarations</a> </dd>
</dl>
<p>4.0 <a href="#4.0">White Space Usage</a></p>
<dl>
  <dd>4.1 <a href="#4.1">Blank Lines</a> </dd>
  <dd>4.2 <a href="#4.2">Blank Spaces</a>
    <dl>
      <dd>4.2.1 <a href="#4.2.1">A single blank space (not tab) should
be used</a> </dd>
      <dd>4.2.2 <a href="#4.2.2">Blanks should <em>not</em> be used</a>
      </dd>
    </dl>
  </dd>
  <dd>4.3 <a href="#4.3">Indentation</a> </dd>
  <dd>4.4 <a href="#4.4">Continuation Lines</a> </dd>
</dl>
<p>5.0 <a href="#5.0">Comments</a></p>
<dl>
  <dd>5.1 <a href="#5.1">Block Comments</a> </dd>
  <dd>5.2 <a href="#5.2">Single-Line Comments</a> </dd>
</dl>
<p>6.0 <a href="#6.0">Classes</a></p>
<dl>
  <dd>6.1 <a href="#6.1">Class Body Organization</a> </dd>
  <dd>6.2 <a href="#6.2">Method Declarations</a> </dd>
  <dd>6.3 <a href="#6.3">Data Store Declarations</a> </dd>
</dl>
<p>7.0 <a href="#7.0">Interfaces</a></p>
<dl>
  <dd>7.1 <a href="#7.1">Interface Body Organization</a> </dd>
</dl>
<p>8.0 <a href="#8.0">Statements</a></p>
<dl>
  <dd>8.1 <a href="#8.1">Simple Statements</a>
    <dl>
      <dd>8.1.1 <a href="#8.1.1">Assignment and expression statements</a>
      </dd>
      <dd>8.1.2 <a href="#8.1.2">Local variable declarations</a> </dd>
      <dd>8.1.3 <a href="#8.1.3">Array declarations</a> </dd>
    </dl>
  </dd>
  <dd>8.2 <a href="#8.2">Compound Statements</a>
    <dl>
      <dd>8.2.3 <a href="#8.2.3">if statement</a> </dd>
      <dd>8.2.4 <a href="#8.2.4">for statement</a> </dd>
      <dd>8.2.5 <a href="#8.2.5">while statement</a> </dd>
      <dd>8.2.6 <a href="#8.2.6">repeat until statement</a> </dd>
      <dd>8.2.7 <a href="#8.2.7">case statement</a> </dd>
      <dd>8.2.8 <a href="#8.2.8">try statement</a> </dd>
    </dl>
  </dd>
</dl>
<p>9.0 <a href="#9.0">Miscellanous</a></p>
<dl>
  <dd>9.1 <a href="#9.1">Const, Var and Type</a> </dd>
  <dd>9.2 <a href="#9.2">Conditional compilation</a> </dd>
  <dd>9.3 <a href="#9.3">Resource strings</a> </dd>
  <dd>9.4 <a href="#9.4">Exceptions</a> </dd>
  <dd>9.5 <a href="#9.5">Categories and routine separation</a> </dd>
  <dd>9.6 <a href="#9.6">Assembler</a> </dd>
  <dd>9.7 <a href="#9.7">Local routines</a> </dd>
  <dd>9.8 <a href="#9.8">Parameter Declarations</a> </dd>
  <dd>9.9 <a href="#9.9">Initialization of global variables</a> </dd>
</dl>
<h2><a name="1.0"></a>1.0 Introduction</h2>
<p>This document is not an attempt to define a grammar for the Object
Pascal language. For instance, it is illegal to place a semicolon
before an else statement; the compiler simply won't let you do it. As a
result, I do not lay that rule out in this style guide. This document
is meant to define the proper course of action in places where the
language gives you a choice. I usually remain mute on matters that can
only be handled one way.</p>
<h5><a name="1.1"></a>1.1 Background</h5>
<p>The guidelines presented here are based on the public portions of
the Delphi source. The Delphi source should follow these guidelines
precisely. If you find cases where the source varies from these
guidelines, then these guidelines, and not the errant source code,
should be considered your standard. Nevertheless, you should use the
source as a supplement to these guidelines, at least so far as it can
help you get a general feel for how your code should look.</p>
<h5><a name="1.2"></a>1.2 Acknowledgments</h5>
<p>The format of this document and some of its language is based on
work done to define a style standard for the Java language. Java has
had no influence on the rules for formatting Object Pascal source, but
documents found on the Sun web site formed the basis for this document.
In particular the style and format of this document were heavily
influenced by "A Coding Style Guide for Java WorkShop and Java Studio
Programming" by Achut Reddy. That document can be found at the
following URL: <a href="http://www.sun.com/workshop/java/wp-coding">http://www.sun.com/workshop/java/wp-coding</a></p>
<p>&nbsp;</p>
<p>The Delphi team also contributed
heavily to the generation of this document, and indeed, it would not
have been possible to create it without their help.</p>
<p>&nbsp;</p>
<p>Many of the modifications to this document where at least partly
based on feedback by Marcel van Brakel and Mike Lischke. Other people
who contributed are Robert Marquardt and Matthias Thoma.</p>
<h2>&nbsp;</h2>
<h2><a name="2.0"></a>2.0 Source Files</h2>
<p>Object Pascal source is divided up primarily into units and Delphi
Project files, which both follow the same conventions. A Delphi Project
file has a DPR extension. It is the main source file for a project. Any
units used in the project will have a PAS extension. Additional files,
such as batch files, html files, or DLLs, may play a role in a project,
but this paper only treats the formatting of DPR and PAS files.</p>
<h5><a name="2.1"></a>2.1 Source-File Naming</h5>
<p>Object Pascal supports long file names. If you are appending several
words to create a single name, then it is best to use capital letters
for each word in the name: MyFile.pas. This is known as InfixCaps, or
Camel Caps. Extensions should be in lower case. For historical reasons,
the Delphi source itself often confines itself to 8:3 naming patterns,
but developers no longer need feel constrained by those limits, even if
turning in source that might be used by the Delphi team.</p>
<p>&nbsp;</p>
<p>If you are translating a C/C++ header file, then your Pascal header
translation will usually have the same name as the file you are
translating, except it should have a PAS extension. For instance,
Windows.h would become Windows.pas. If the rules of Pascal grammar
force you to combine multiple header files into a single unit, then use
the name of the base unit into which you are folding the other files.
For instance, if you fold WinBase.h into Windows.h, then call the
resulting file Windows.pas.</p>
<p>&nbsp;</p>
<p>All JEDI Visal Component Library source-files must be prefixed with
'Jv'. Also, since these files are to be ported to Linux be carefull
that you use the same capitalization everywhere a source-file is
referenced (Linux filenames are, as opposed to Win32, case-sensitive).</p>
<h5><a name="2.2"></a>2.2 Source-File Organization</h5>
<p>All Object Pascal units should contain the following elements in the
following order:</p>
<p>&nbsp;</p>
<ol>
  <li>
    <p>Copyright/ID block comment</p>
  </li>
  <li>CVS Id marker<br>
  </li>
  <li>
    <p>Unit Name</p>
  </li>
  <li>
    <p>Include files</p>
  </li>
  <li>
    <p>Interface section</p>
  </li>
  <li>
    <p>Additional defines</p>
  </li>
  <li>
    <p>Uses clause</p>
  </li>
  <li>
    <p> Implementation</p>
  </li>
  <li>
    <p>Uses clause</p>
  </li>
  <li>
    <p>A closing end and a period.</p>
  </li>
  <li>
    <p>At least one blank line should separate each of these elements.</p>
    <p>&nbsp;</p>
  </li>
</ol>
<p>&nbsp;</p>
<p>Additional elements can be structured in the order you find most
appropriate, except that the top of the file should always list the
copyright first, the unit name second, then any conditional defines,
compiler directives or include statements, then the uses clause. For
the JVCL the following header is used. Replace JvGraphics with the
appropriate unit name. The Last Modified date is kept up to date by the
unit owner and should always match the last modified date in the
filesystem.</p>
<p>&nbsp;</p>
<pre>{-----------------------------------------------------------------------------<br>The contents of this file are subject to the Mozilla Public License<br>Version 1.1 (the "License"); you may not use this file except in compliance<br>with the License. You may obtain a copy of the License at<br>http://www.mozilla.org/MPL/MPL-1.1.html<br><br>Software distributed under the License is distributed on an "AS IS" basis,<br>WITHOUT WARRANTY OF ANY KIND, either expressed or implied. See the License for<br>the specific language governing rights and limitations under the License.<br><br>The Original Code is: JvActions.Pas, released on 2002-10-04.<br><br>The Initial Developer of the Original Code is Sébastien Buysse [sbuysse att buypin dott com]<br>Portions created by Sébastien Buysse are Copyright (C) 2002 Sébastien Buysse.<br>All Rights Reserved.<br><br>Contributor(s): -<br><br>You may retrieve the latest version of this file at the Project JEDI's JVCL home page,<br>located at http://jvcl.sourceforge.net<br><br>Known Issues:<br>-----------------------------------------------------------------------------}<br>// $Id$<br><br>unit JvActions;</pre>
<p>&nbsp;</p>
<p>Compiler directives are not directly included in the source files.
Instead a global JVCL.INC include file is used which defines all
standard directives. Ex.</p>
<pre>&nbsp;</pre>
<pre>{$I JVCL.INC}<br><br>interface</pre>
<p>&nbsp;</p>
<p>If overriding directives are needed they can be included below this
include but this must be avoided. If overriding directives are needed
these must be documented. You should strive to override directives only
a local scope. For example, for a single procedure.</p>
<pre>&nbsp;</pre>
<pre>{$S-,W-,R-}<br>{$C PRELOAD}<br><br>interface<br><br>uses<br>  Windows, Messages, Classes, Controls, Forms, Graphics, StdCtrls, ExtCtrls, CommCtrl;</pre>
<p>&nbsp;</p>
<p>It does not matter if you place a type section before a const
section, or if you mix type and const sections up in any order you
choose.</p>
<p>The implementation should list the word implementation first, then
the uses clause, then any include statements or other directives:</p>
<pre>implementation<br><br>uses<br>  Consts, SysUtils, ActnList, ImgList;<br><br>{$R BUTTONS.RES}</pre>
<h5><a name="2.2.2"></a>2.2.1 Unit declaration</h5>
<p>Every source file should contain a unit declaration. The word unit
is a reserved word, so it should be in lower case. The name of the unit
should be in mixed upper and lowercase, and must be the same as the
name used by the operating system's file system. Example:</p>
<pre>&nbsp;</pre>
<pre>unit JvMyUnit;</pre>
<p>&nbsp;</p>
<p>This unit would be called MyUnit.pas when an entry is placed in the
file system.</p>
<h5><a name="2.2.3"></a>2.2.2 uses declarations</h5>
<p>Inside units, a uses declaration should begin with the word uses, in
lowercase. Add the names of the units, following the capitalization
conventions used in the declaration found inside the units:</p>
<pre>&nbsp;</pre>
<pre>uses MyUnit;</pre>
<p>&nbsp;</p>
<p>Each unit must be separated from its neighbor by a comma, and the
last unit should have a semicolon after it:</p>
<pre>&nbsp;</pre>
<pre>uses<br>  Windows, SysUtils, Classes, Graphics, Controls, Forms, TypInfo; </pre>
<pre>&nbsp;</pre>
<p>The uses clause is always started on the next line and units are
written down one after another, wrapping at 100 columns. Furthermore,
you should separate the standard Delphi units, JVCL units and Platform
dependent units. Finally, it is prefered to list to units in
alpabetical order unless the order is important (this should never be
the case but sometimes is, an example is the Windows unit which - by
convention - should always be listed first). An example follows
(comments shouldn't be included):</p>
<pre>&nbsp;</pre>
<pre>uses<br>  {$IFDEF WIN32}<br>  Windows, ActiveX,    // Windows units<br>  {$ENDIF}<br>  {$IFDEF LINUX}<br>  ..Linux specific units go here<br>  {$ENDIF}<br>  Math, SysUtils,      // Standard Delphi platform independent units<br>  JVCLBase, JVCLStrings; // JVCL units</pre>
<h5><a name="2.2.4"></a>2.2.3 class/interface declarations</h5>
<p>A class declaration begins with two spaces, followed by an
identifier prefaced by TJv. Identifiers should begin with a capital
letter, and should have capital letters for each embedded word
(InfixCaps). Never use tab characters in your Object Pascal source.
Example:</p>
<pre>&nbsp;</pre>
<pre>TJvMyClass</pre>
<p>&nbsp;</p>
<p>Follow the identifier with a space, then an equals sign, then the
word class (all in lower case), furthermore a parenthesis, the name of
the ancestor class, and closing parenthesis. The class keyword and
ancestor should be separated with a space:</p>
<p>&nbsp;</p>
<p>TJvMyClass = class (TObject)</p>
<p>&nbsp;</p>
<p>Scoping directives should be two spaces in from the margin, and
declared in the order shown in this example:</p>
<pre>&nbsp;</pre>
<pre>  TJvMyClass = class (TObject)<br>  private<br>  protected<br>  public<br>  published<br>  end;</pre>
<p>&nbsp;</p>
<p>Data should always be declared only in the private section, and its
identifier should be prefaced by an F. All type declarations should be
four spaces in from the margin:</p>
<pre>&nbsp;</pre>
<pre>  TJvMyClass = class (TObject)<br>  private<br>    FMyData: Integer;<br>  protected<br>    function GetData: Integer;<br>    procedure SetData(Value: Integer);<br>  public<br>  published<br>    property MyData: Integer read GetData write SetData;<br>  end;</pre>
<p>&nbsp;</p>
<p><a href="#7.0">Interfaces</a> follow the same rules as class
declarations, except you should omit any scoping directives or private
data, and should use the word interface rather than class.<br>
Property accessor functions should be in the protected section so that
a user deriving a class from yours can use them. Should there be no
accessor (either read or write) then the field itself should be in the
protected section.<br>
</p>
<h2>&nbsp;</h2>
<h2><a name="3.0"></a>3.0 Naming Conventions</h2>
<p>Except for reserved words and directives, which are in all
lowercase, all Pascal identifiers should use InfixCaps, which means the
first letter should be a capital, and any embedded words in an
identifier should be in caps, as well as any acronym that is embedded:</p>
<pre>&nbsp;</pre>
<pre>MyIdentifier MyFTPClass</pre>
<p>&nbsp;</p>
<p>The major exception to this rule is in the case of header
translations, which should always follow the conventions used in the
header. For instance, write WM_LBUTTONDOWN, not wm_LButtonDown.</p>
<p>&nbsp;</p>
<p>Except in header translations, do not use underscores to separate
words. Class names should be nouns or noun phrases. Interface or class
names depend on the salient purpose of the interface.</p>
<p>&nbsp;</p>
<p>GOOD type names:</p>
<dl>
  <dd>AddressForm </dd>
  <dd>JvArrayIndexOutOfBoundsException </dd>
</dl>
<p>BAD type names:</p>
<dl>
  <dd>ManageLayout (verb phrase) </dd>
  <dd> delphi_is_new_to_me (underscores) </dd>
</dl>
<p>It seems to be unavoidable but every now and then someone suggests
using hungarian, or a similar, notation for identifier naming. Although
good arguments can be provided in favor of hungarian notation, at least
as many arguments can be given against it. The JVCL will not use
hungarian notation, ever! There, that's out of the way. Identifiers in
the JVCL should be named as the examples above, names which describe
the purpose of the identifier not what type they happen to be of.</p>
<h5><a name="3.1"></a>3.1 Unit Naming</h5>
<p>Use InfixCaps, as described at the beginning of this section. See
also the section on <a href="#2.2.2">unit declarations</a></p>
<p>&nbsp;</p>
<p>As described earlier, all JVCL units should have the "Jv" prefix.</p>
<h5><a name="3.2"></a>3.2 Class/Interface Naming</h5>
<p>Use InfixCaps, as described at the beginning of this section. Begin
each type declaration with a capital T:</p>
<pre>&nbsp;</pre>
<pre>TJvMyType</pre>
<p>&nbsp;</p>
<p>See also the section on <a href="#2.2.4">class/interface
declarations.</a></p>
<p>&nbsp;</p>
<p>All JVCL classes are prefixed with 'TJv' not just a capital T. Types
which are used only internally don't have to include the 'Jv' prefix
although you should be carefull with the naming when they are declared
in the interface section.</p>
<h5><a name="3.3"></a>3.3 Field Naming</h5>
<p>Use InfixCaps, as described at the beginning of this section. Begin
each type declaration with a capital F, and declare all data types in
the private section, using properties or getters and setters to provide
public or protected access. For example, use the name GetSomething to
name a function returning an internal field value and use SetSomething
to name a procedure setting that value.</p>
<p>&nbsp;</p>
<p>Do not use all caps for const declarations except where required in
header translations.</p>
<p>&nbsp;</p>
<p>Delphi is created in California, so we discourage the use of
hungarian notation, except where required in header translations:</p>
<pre>&nbsp;</pre>
<pre>CORRECT<br>  FMyString: string;<br><br>INCORRECT<br>  lpstrMyString: string;</pre>
<p>&nbsp;</p>
<p>The exception to the Hungarian notation rule is in enumerated types.</p>
<pre>&nbsp;</pre>
<pre>  TBitBtnKind = (bkCustom, bkOK, bkCancel, bkHelp,<br>    bkYes, bkNo, bkClose, bkAbort, bkRetry,<br>    bkIgnore, bkAll);</pre>
<p>&nbsp;</p>
<p>In this case the letters bk are inserted before each element of this
enumeration. bk stands for ButtonKind.</p>
<p>When thinking about naming conventions, consider that one-character
field names should be avoided except for temporary and looping
variables.</p>
<p>Looping variables are by convention named I (capital i) and J. Other
commonly used single character identifier names are: S (string) and R
(Result). Single letter variables/field names should always be capitals
but other than the ones mentioned above you should avoid them and use
more meaningful names.</p>
<p>Avoid variable l ("el") because it is hard to distinguish it from 1
("one") on some printers and displays.</p>
<h5><a name="3.4"></a>3.4 Method Naming</h5>
<p>Method names should use the InfixCaps style. Start with a capital
letter, and capitalize the first letter of any subsequent word in the
name, as well as any letters that are part of an acronym. All other
characters in the name are lower case. Do not use underscores to
separate words. Note that this is identical to the naming convention
for non-constant fields; however it should always be easy to
distinguish the two from context. Method names should be imperative
verbs or verb phrases.</p>
<p>&nbsp;</p>
<p>Examples:</p>
<dl>
  <dd>&nbsp; </dd>
  <dd><b><i>Good method names:</i></b>
    <dl>
      <dd>ShowStatus </dd>
      <dd>DrawCircle </dd>
      <dd>AddLayoutComponent </dd>
    </dl>
  </dd>
  <dd><b><i>Bad method names:</i></b>
    <dl>
      <dd>MouseButton (noun phrase; doesn't describe function) </dd>
      <dd>drawCircle (starts with lower-case letter) </dd>
      <dd>add_layout_component (underscores) </dd>
      <dd> ServerRunning (verb phrase, but not imperative) </dd>
    </dl>
  </dd>
</dl>
<p>A note about the last example (ServerRunning): The function of this
method is unclear. Does it start the server running (better:
StartServer), or test whether or not it is running (better:
IsServerRunning)?</p>
<p>&nbsp;</p>
<p>A method to get or set some property of the class should be called
GetProperty or SetProperty respectively, where Property is the name of
the property.</p>
<p>&nbsp;</p>
<p>Examples:</p>
<pre>&nbsp;</pre>
<pre>GetHeight, SetHeight</pre>
<p>&nbsp;</p>
<p>A method to test some boolean property of the class should be called
IsVisible, where Visible is the name of the property.</p>
<p>&nbsp;</p>
<p>Examples:</p>
<pre>&nbsp;</pre>
<pre>IsResizable, IsVisible</pre>
<h5><a name="3.5"></a>3.5 Local Variable Naming</h5>
<p>Local variables follow the same naming rules as field names, except
you omit the initial F, since this is not a Field of an object. (see <a
 href="#3.3">section 3.3</a>).</p>
<h5><a name="3.6"></a>3.6 Reserved Words</h5>
<p>Reserved words and directives should be all lowercase. This can be a
bit confusing at times. For instance types such as Integer are just
identifiers, and appear with a first cap. Strings, however, are
declared with the reserved word string, which should be all lowercase.</p>
<h5><a name="3.7"></a>3.7 Type Declarations</h5>
<p>All type declarations should begin with the letter T, and should
follow the same capitalization specification laid out in the <a
 href="#3.0">beginning</a> of this section, or in the section on <a
 href="#2.2.4">class declarations.</a></p>
<p>&nbsp;</p>
<h2><a name="4.0"></a>4.0 White Space Usage</h2>
<h5><a name="4.1"></a>4.1 Blank Lines</h5>
<p>Blank lines can improve readability by grouping sections of the code
that are logically related. A blank line should also be used in the
following places:</p>
<p>&nbsp;</p>
<ol>
  <li>
    <p>After the copyright block comment, package declaration, and
import section.</p>
  </li>
  <li>
    <p>Between class declarations.</p>
  </li>
  <li>
    <p>Between method declarations.</p>
  </li>
</ol>
<h5><a name="4.2"></a>4.2 Blank Spaces</h5>
<p>Object Pascal is a very clean, easy to read language. In general,
you don't need to add a lot of spaces in your code to break up lines.
The next few sections give you some guidelines to follow when placing
spaces in your code.</p>
<h5><a name="4.2.2"></a>4.2.2 Blanks should <em>not</em> be used:</h5>
<ol>
  <li>
    <p>Between a method name and its opening parenthesis.</p>
  </li>
  <li>
    <p>Before or after a .(dot) operator.</p>
  </li>
  <li>
    <p>Between a unary operator and its operand.</p>
  </li>
  <li>
    <p>Between a cast and the expression being cast.</p>
  </li>
  <li>
    <p>After an opening parenthesis or before a closing parenthesis.</p>
  </li>
  <li>
    <p>After an opening square bracket [ or before a closing square
bracket ].</p>
  </li>
  <li>
    <p>Before a semicolon.</p>
  </li>
</ol>
<p>&nbsp;</p>
<p>Examples of correct usage:</p>
<pre>&nbsp;</pre>
<pre>function TMyClass.MyFunc(var Value: Integer);<br>MyPointer := @MyRecord;<br>MyClass := TMyClass(MyPointer);<br>MyInteger := MyIntegerArray[5];</pre>
<p>Examples of incorrect usage:</p>
<pre>function TMyClass.MyFunc( var Value: Integer ) ;<br>MyPointer := @ MyRecord;<br>MyClass := TMyClass ( MyPointer ) ;<br>MyInteger := MyIntegerArray [ 5 ] ;</pre>
<h5><a name="4.3"></a>4.3 Indentation</h5>
<p>You should always indent two spaces for all indentation levels. In
other words, the first level of indentation is two spaces, the second
level four spaces, the third level 6 spaces, etc. Never use tab
characters.</p>
<p>&nbsp;</p>
<p>There are few exceptions. The reserved words unit, uses, type,
interface, implementation, initialization and finalization should
always be flush with the margin. The final end statement at the end of
a unit should be flush with the margin. In the project file, the word
program, and the main begin and end block should all be flush with the
margin. The code inside the begin..end block, should be indented at
least two spaces.</p>
<h5><a name="4.4"></a>4.4 Continuation Lines</h5>
<p>Lines should be limited to 100 columns. Lines longer than 100
columns should be broken into one or more continuation lines, as
needed. All the continuation lines should be aligned and indented from
the first line of the statement, and indented two characters. Always
place begin statements on their own line.</p>
<p>&nbsp;</p>
<p>Examples:</p>
<pre>&nbsp;</pre>
<pre>// CORRECT<br><br>function CreateWindowEx(dwExStyle: DWORD;<br>  lpClassName: PChar; lpWindowName: PChar;<br>  dwStyle: DWORD; X, Y, nWidth, nHeight: Integer;<br>  hWndParent: HWND; hMenu: HMENU; hInstance: HINST;<br>  lpParam: Pointer): HWND; stdcall;<br><br><br>if ((X = Y) or (Y = X) or<br>  (Z = P) or (F = J) then<br>begin<br>  S := J;<br>end;</pre>
<p>&nbsp;</p>
<p>Never wrap a line between a parameter and its type, unless it is a
comma separated list, then wrap at least before the last parameter so
the type name follows to the next line. The colon for all variable
declarations contains no whitespace between it and the variable. There
should be a single space following the colon before the type name;</p>
<p>&nbsp;</p>
<pre>procedure Foo(Param1: Integer; Param2: Integer);<br><br><br>procedure Foo( Param :Integer; Param2:Integer );</pre>
<p>&nbsp;</p>
<p>A continuation line should never start with a binary operator. Avoid
breaking a line where normally no white space appears, such as between
a method name and its opening parenthesis, or between an array name and
its opening square bracket. If you must break under these
circumstances, then one viable place to begin is after the opening
parenthesis that follows a method name. Never place a begin statement
on the same line with any other code.</p>
<p>&nbsp;</p>
<p>Examples:</p>
<p>&nbsp;</p>
<pre>// INCORRECT<br>while (LongExpression1 or LongExpression2) do begin<br>  // DoSomething<br>  // DoSomethingElse;<br>end;<br><br>// CORRECT<br>while (LongExpression1 or LongExpression2) do <br>begin<br>  // DoSomething<br>  // DoSomethingElse;<br>end;<br><br>if (LongExpression1)  <br>   or (LongExpression2) <br>   or (LongExpression3) then<br>// CORRECT<br>if (LongExpression1) or <br>  (LongExpression2) or <br>  (LongExpression3) then <br>  </pre>
<h2><a name="5.0"></a>5.0 Comments</h2>
<p>The Object Pascal language supports two kinds of comments: block,
and single-line comments. Some general guidelines for comment usage
include:</p>
<p>&nbsp;</p>
<ul>
  <li>
    <p>It is helpful to place comments near the top of unit to explain
its purpose.</p>
  </li>
  <li>
    <p>It is helpful to place comments before a class declaration.</p>
  </li>
  <li>
    <p>It is helpful to place comments before some method declarations.</p>
  </li>
  <li>
    <p>Avoid making obvious comments:</p>
  </li>
</ul>
<pre>&nbsp;</pre>
<pre>i := i + 1;     // Add one to i</pre>
<pre>&nbsp;</pre>
<ul>
  <li>
    <p>Remember that misleading comments are worse than no comments at
all.</p>
  </li>
  <li>
    <p>Avoid putting any information into comments that is likely to
become out of date.</p>
  </li>
  <li>
    <p>Avoid enclosing comments in boxes drawn with asterisks or other
special typography.</p>
  </li>
  <li>
    <p>Temporary comments that are expected to be changed or removed
later should be marked with the special tag "TODO:" so that they can
easily be found afterwards. Ideally, all temporary comments should have
been removed by the time a program is ready to be shipped.</p>
  </li>
</ul>
<p>&nbsp;</p>
<p>Example:</p>
<p>&nbsp;</p>
<pre>// TODO: Change this to call Sort when it is fixed<br>List.MySort;</pre>
<h5><a name="5.1"></a>5.1 Block Comments</h5>
<p>&nbsp;</p>
<p>Object Pascal supports two types of block comments. The most
commonly used block comment is a pair of curly braces: { }. The Delphi
team prefers to keep comments of this type as spare and simple as
possible. For instance, you should avoid using asterisks to create
patterns or lines inside your comments. Instead, make use of white
space to break your comments up, much as you would in a word processing
document. The words in your comments should start on the same line as
the first curly brace, as shown in this excerpt from DsgnIntf.pas:</p>
<p>&nbsp;</p>
<pre>{ TPropertyEditor<br><br>  Edits a property of a component, or list of components,<br>  selected into the Object Inspector.  The property<br>  editor is created based on the type of the<br>  property being edited as determined by the types<br>  registered by...<br><br>  etc...<br><br>    GetXxxValue<br>      Gets the value of the first property in the<br>      Properties property.  Calls the appropriate<br>      TProperty GetXxxValue method to retrieve the<br>      value.<br><br>    SetXxxValue Sets the value of all the properties<br>      in the Properties property.  Calls the appropriate<br>      TProperty SetXxxxValue methods to set the value. }</pre>
<pre>&nbsp;</pre>
<p>A block comment is always used for the copyright/ID comment at the
beginning of each source file. It is also used to "comment out" several
lines of code.</p>
<p>Block comments used to describe a method should appear before the
method declaration.</p>
<p>&nbsp;</p>
<p>Example:</p>
<p>&nbsp;</p>
<pre>// CORRECT<br><br>{ TMyObject.MyMethod<br><br>  This routine allows you to execute code. }<br><br>procedure TMyObject.MyMethod;<br>begin<br>end;<br><br><br>// INCORRECT<br><br>procedure TMyObject.MyMethod;<br>{******************************************************<br>  TMyObject.MyMethod<br><br>  This routine allows you to execute code.<br>*******************************************************}<br>begin<br>end;</pre>
<pre>&nbsp;</pre>
<p>A second kind of block comment contains two characters, a
parenthesis and an asterisk: (* *). This is sometimes called starparen
comments. These comments are generally useful only during code
development, as their primary benefit is that they allow nesting of
comments, as long as the nest level is less than 2. Object Pascal
doesn't support nesting comments of the same type within each other, so
really there is only one level of comment nesting: curly inside of
starparen, and starparen inside of curly. As long as you don't nest
them, any other standard Pascal comments between comments of this type
will be ignored. As a result, you can use this syntax to comment out a
large chunk of code that is full of mixed code and comments:</p>
<p>&nbsp;</p>
<pre>(* procedure TForm1.Button1Click(Sender: TObject);<br>begin<br>  DoThis; // Start the process<br>  DoThat; // Continue iteration<br>  { We need a way to report errors here, perhaps using<br>    a try finally block ??? }<br>  CallMoreCode; // Finalize the process<br>end; *)</pre>
<pre>&nbsp;</pre>
<p>In this example, the entire Button1Click method is commented out,
including any of the subcomments found between the procedure's
begin..end pair.</p>
<h5><a name="5.2"></a>5.2 Single-Line Comments</h5>
<p>A single-line comment consists of the characters // followed by
text. Include a single space between the // and the comment itself.
Place single line comments at the same indentation level as the code
that follows it. You can group single-line comments to form a larger
comment.</p>
<p>A single-line comment or comment group should always be preceded by
a blank line, unless it is the first line in a block. If the comment
applies to a group of several statements, then the comment or comment
group should also be followed by a blank line. If it applies only to
the next statement (which may be a compound statement), then do not
follow it with a blank line.</p>
<p>&nbsp;</p>
<p>Example:</p>
<p>&nbsp;</p>
<pre>Table1.Open;</pre>
<pre>&nbsp;</pre>
<p>Single-line comments can also follow the code they reference. These
comments, sometimes referred to as trailing comments, appear on the
same line as the code they describe. They should have at least one
space-character separating them from the code they reference. If more
than one trailing comment appears in a block of code, they should all
be aligned to the same column.</p>
<p>&nbsp;</p>
<p>Example:</p>
<p>&nbsp;</p>
<pre>if (not IsVisible) then<br>  Exit;          // nothing to do<br>Inc(StrLength);  // reserve space for null terminator</pre>
<pre>&nbsp;</pre>
<p>Avoid commenting every line of executable code with a trailing
comment. It is usually best to limit the comments inside the begin..end
pair of a method or function to a bare minimum. Longer comments can
appear in a block comment before the method or function declaration.</p>
<p>&nbsp;</p>
<h2><a name="6.0"></a>Classes</h2>
<h5><a name="6.1"></a>6.1 Class Body Organization</h5>
<p>The body of a class declaration should be organized in the following
order:</p>
<p>&nbsp;</p>
<ul>
  <li>
    <p>Field declarations</p>
  </li>
  <li>
    <p>Method declarations</p>
  </li>
  <li>
    <p>Property declarations</p>
  </li>
</ul>
<p>&nbsp;</p>
<p>The fields, properties and methods in your class should be arranged
alphabetically by name.</p>
<h5><a name="6.1.1"></a>6.1.1 Access levels</h5>
<p>Except for code inserted by the IDE, the scoping directives for a
class should be declared in the following order:</p>
<p>&nbsp;</p>
<ul>
  <li>
    <p>Private declarations</p>
  </li>
  <li>
    <p>Protected declarations</p>
  </li>
  <li>
    <p>Public declarations</p>
  </li>
  <li>
    <p>Published declarations</p>
  </li>
</ul>
<p>&nbsp;</p>
<p>There are <em>four</em> access levels for class members in Object
Pascal: published, public, protected, and private -- in order of
decreasing accessibility. By default, the access level is published. In
general, a member should be given the lowest access level which is
appropriate for the member. For example, a member which is only
accessed by classes in the same unit should be set to <em>private</em>
access. Also, declaring a lower access level will often give the
compiler increased opportunities for optimization. On the other hand,
use of private makes it difficult to extend the class by sub-classing.
If there is reason to believe the class might be sub-classed in the
future, then members that might be needed by sub-classes should be
declared protected instead of private, and the properties used to
access private data should be given protected status.</p>
<p>You should never allow public access to data. Data should always be
declared in the private or protected section, and any public access
should be via getter and setter methods, or properties.</p>
<h5><a name="6.1.8"></a>6.1.8 Constructor declarations</h5>
<p>Methods should be arranged alphabetically. It is correct either to
place your constructors and destructors at the head of this list in the
public section, or to arrange them in alphabetical order within the
public section. If you have a large number of methods, you may want to
group them by functionnality, and then order them alphabetically in the
group. Always separate groups by a blank line.<br>
</p>
<p>&nbsp;</p>
<p>If there is more than one constructor, and if you choose to give
them all the same name, then sort them lexically by formal parameter
list, with constructors having more parameters always coming after
those with fewer parameters. This implies that a constructor with no
arguments (if it exists) is always the first one. For compatibility
with C++Builder, you must make the parameter lists of your constructors
unique. C++ cannot call constructors by name, so the only way to
distinguish between multiple constructors is by parameter list.</p>
<h5><a name="6.2"></a>6.2 Method Declarations</h5>
<p>If possible, a method declaration should appear on one line.</p>
<p>&nbsp;</p>
<p>Examples:</p>
<p>&nbsp;</p>
<pre>procedure ImageUpdate(Image img, infoflags: Integer,<br>  x: Integer, y: Integer, w: Integer, h: Integer)</pre>
<pre>&nbsp;</pre>
<h2><a name="7.0"></a>Interfaces</h2>
<p>Interfaces are declared in a manner that runs parallel to the
declaration for classes:</p>
<p>&nbsp;</p>
<pre>InterfaceName = interface([Inherited Interface])<br>InterfaceBody<br>end;</pre>
<pre>&nbsp;</pre>
<ul>
  <li>An interface declaration should be indented two spaces. The <em>body</em>
of the interface is indented by the standard indentation of four
spaces. The closing end statement should also be indented two
characters. There should be a semi-colon following the closing end
statement.</li>
</ul>
&nbsp;
<ul>
  <li>There are no fields in an interface declaration. Properties,
however, are allowed.</li>
</ul>
&nbsp;
<ul>
  <li>All interface methods are inherently public and abstract; do not
explicitly include these keywords in the declaration of an interface
method.</li>
</ul>
&nbsp;
<ul>
  <li>Except as otherwise noted, interface declarations follow the same
style guidelines as classes.</li>
</ul>
<h5><a name="7.1"></a>7.1 Interface Body Organization</h5>
<p>The body of an interface declaration should be organized in the
following order:</p>
<p>&nbsp;</p>
<ol>
  <li>
    <p>Interface method declarations</p>
  </li>
  <li>
    <p>Interface property declarations</p>
  </li>
</ol>
<p>&nbsp;</p>
<p>The declaration styles of interface properties and methods are
identical to the styles for class properties and methods.</p>
<p>&nbsp;</p>
<h2><a name="8.0"></a>8.0 Statements</h2>
<p>Statements are one or more lines of code followed by a semicolon.
Simple statements have one semicolon, while compound statements have
more than one semicolon and therefore consist of multiple simple
statements.</p>
<p>&nbsp;</p>
<p>Here is a simple statement:</p>
<pre>&nbsp;</pre>
<pre>A := B; </pre>
<p>&nbsp;</p>
<p>Here is a compound, or structured, statement:</p>
<pre>&nbsp;</pre>
<pre>begin<br>  B := C;<br>  A := B;<br>end;</pre>
<pre>&nbsp;</pre>
<h2><a name="8.0.1"></a>8.0.1 Simple Statements</h2>
<p>A simple statement contains a single semicolon. If you need to wrap
the statement, indent the second line two spaces in from the previous
line:</p>
<p>&nbsp;</p>
<pre>MyValue :=<br>  MyValue + (SomeVeryLongStatement / OtherLongStatement);</pre>
<pre>&nbsp;</pre>
<h2><a name="8.0.2"></a>8.0.1 Compound Statements</h2>
<p>Compound Statements always end with a semicolon, even if it is
syntactically not required. For example the last statement in the
following example must have a terminating semicolon for it to be
acceptable in the JVCL.</p>
<pre>&nbsp;</pre>
<pre>begin<br>  MyStatement;<br>  MyNextStatement;<br>  MyLastStatement;   // semicolon optional<br>end;</pre>
<pre>&nbsp;</pre>
<p><a name="8.1.1"></a><b>8.1.1 Assignment and expression statements</b></p>
<p>&nbsp;</p>
<p>Each line should contain at most one statement. For example:</p>
<p>&nbsp;</p>
<pre>a := b + c; Inc(Count); // INCORRECT<br>a := b + c;             // CORRECT<br>Inc(Count);             // CORRECT</pre>
<h5><a name="8.1.2"></a>8.1.2 Local variable declarations</h5>
<p>Local variables should have Camel Caps, that is, they should start
with a capital letter, and have capital letters for the beginning of
each embedded word. Do not preface variable names with an F, as that
convention is reserved for Fields in a class declaration:</p>
<p>&nbsp;</p>
<pre>var<br>  MyData: Integer;<br>  MyString: string;</pre>
<p>You may declare multiple identifiers of the same type on a single
line:</p>
<p>&nbsp;</p>
<pre>var<br>  ArraySize, ArrayCount: Integer;</pre>
<p>&nbsp;</p>
<p>This practice is discouraged in class declarations. There you should
place each field on a separate line, along with its type.</p>
<p>You should only declare identifiers on a single line if they are
logically related.</p>
<h5><a name="8.1.3"></a>8.1.3 Array declarations</h5>
<p>There should always be a space before the opening bracket "[" and
after the closing bracket.</p>
<p>&nbsp;</p>
<pre>type<br>  TMyArray = array [0..100] of Char;</pre>
<h5><a name="8.2.3"></a>8.2.3 if statement</h5>
<p>If statements should always appear on at least two lines.</p>
<p>&nbsp;</p>
<p>Example:</p>
<p>&nbsp;</p>
<pre>if A &lt; B then DoSomething;<br><br>if A &lt; B then<br>  DoSomething;</pre>
<pre>&nbsp;</pre>
<p>In the JVCL the first example is allowed but discouraged. Use it
only in "obvious" situations such as "if ParameterIncorrect then Exit;"</p>
<p>In compound if statements, put each element separating statements on
a new line:</p>
<p>&nbsp;</p>
<p>Example:</p>
<p>&nbsp;</p>
<pre>  // INCORRECT<br>  if A &lt; B then begin<br>    DoSomething;<br>    DoSomethingElse;<br>  end else begin<br>    DoThis;<br>    DoThat;<br>  end;<br><br>  // CORRECT<br>  if A &lt; B then<br>  begin<br>    DoSomething;<br>    DoSomethingElse;<br>  end<br>  else<br>  begin<br>    DoThis;<br>    DoThat;<br>  end;<br>  </pre>
<p>Here are a few more variations that are considered valid (except for
the second one, all these variations are discouraged):</p>
<p>&nbsp;</p>
<pre>  // CORRECT<br>  if Condition then<br>  begin<br>    DoThis;<br>  end else<br>  begin<br>    DoThat;<br>  end;<br><br>  // CORRECT<br>  if Condition then<br>  begin<br>    DoThis;<br>  end<br>  else<br>    DoSomething;<br><br>  // CORRECT<br>  if Condition then<br>  begin<br>    DoThis;<br>  end else<br>    DoSomething;<br><br>  if Condition then<br>  begin<br>    DoThis;<br>  end<br>  else DoSomething;<br>  </pre>
<p>One that has fallen out of favor but deserves honorable mention:</p>
<p>&nbsp;</p>
<pre>  if Condition then<br>    DoThis<br>  else DoThat;<br>  </pre>
<p>Avoid extraneous parentheses when formulating the conditional in an
if statement. In other words, don't encapsulate the conditional
statement in parenthesis if it's not syntactically required and doesn't
provide additional readability. An obvious example:</p>
<p>&nbsp;</p>
<pre>  // CORRECT<br>  if I &gt; 0 then <br>    DoSomething;<br>    <br>  // INCORRECT<br>  if (I &gt; 0) then<br>    DoSomething;</pre>
<h5><a name="8.2.4"></a>8.2.4 for statement</h5>
<p>Example:</p>
<p>&nbsp;</p>
<pre>  // INCORRECT<br>  for i := 0 to 10 do begin<br>    DoSomething; <br>    DoSomethingElse;<br>  end;<br><br>  // CORRECT<br>  for i := 0 to 10 do<br>  begin<br>    DoSomething;<br>    DoSomethingElse;<br>  end;</pre>
<p>&nbsp;</p>
<p>If the body of the for loop consist of a single statement then both
of the examples below are allowed. As with if statements, the first one
is discouraged though.</p>
<pre>&nbsp;</pre>
<pre>  for I := 0 to 10 do DoSomething;<br><br>  for I := 0 to 10 do<br>    DoSomething;<br>  </pre>
<h5><a name="8.2.5"></a>8.2.5 while statement</h5>
<p>Example:</p>
<p>&nbsp;</p>
<pre>  // INCORRECT<br>  while x &lt; j  do begin<br>    DoSomething;<br>    DoSomethingElse;<br>  end;<br><br>  // CORRECT<br>  while x &lt; j do<br>  begin<br>    DoSomething;<br>    DoSomethingElse;<br>  end;<br>  </pre>
<p>The same as with for loops applies here. Both of the following
examples are allowed but the first one is discouraged.</p>
<p>&nbsp;</p>
<pre>  while x &lt; j do Something;<br><br>  while x &lt; j do<br>    Something;</pre>
<h5><a name="8.2.6"></a>8.2.6 repeat until statement</h5>
<p>Example:</p>
<p>&nbsp;</p>
<pre>  // CORRECT<br>  repeat<br>    x := j;<br>    j := UpdateValue;<br>  until j &gt; 25;</pre>
<h5><a name="8.2.7"></a>8.2.7 case statement</h5>
<p>Example:</p>
<pre>&nbsp;</pre>
<pre>  // CORRECT<br>  case Control.Align of<br>    alLeft, alNone: NewRange := Max(NewRange, Position);<br>    alRight: Inc(AlignMargin, Control.Width);<br>  end;<br><br><br>  // CORRECT<br>  case ScrollCode of<br>    SB_LINEUP, SB_LINEDOWN:<br>      begin<br>        Incr := FIncrement div FLineDiv;<br>        FinalIncr := FIncrement mod FLineDiv;<br>        Count := FLineDiv;<br>      end;<br>    SB_PAGEUP, SB_PAGEDOWN:<br>      begin<br>        Incr := FPageIncrement;<br>        FinalIncr := Incr mod FPageDiv;<br>        Incr := Incr div FPageDiv;<br>        Count := FPageDiv;<br>      end;<br>  else<br>    Count := 0;<br>    Incr := 0;<br>    FinalIncr := 0;<br>  end;</pre>
<p>&nbsp;</p>
<p>Except the obvious situations in which the first variation is used
for readability, the JVCL only uses the second example. That is, each
case label starts on a separate line with a two column indent relative
to the case statement and the body of that particular case follows on
the next line with an additional two column indent. If the body on a
particular case consists of only a single statement then the
begin...end pair can be omitted. In this case the statement is aligned
using a two column indent relative to the case statement (identical to
the begin reserved word in the example above).</p>
<h5><a name="8.2.8"></a>8.2.8 try statement</h5>
<p>Example:</p>
<pre>&nbsp;</pre>
<pre>  // Correct<br>  try<br>    try<br>      EnumThreadWindows(CurrentThreadID, @Disable, 0);<br>      Result := TaskWindowList;<br>    except<br>      EnableTaskWindows(TaskWindowList);<br>      raise;<br>    end;<br>  finally<br>    TaskWindowList := SaveWindowList;<br>    TaskActiveWindow := SaveActiveWindow;<br>  end;</pre>
<h2><a name="9.0"></a>9.0 Miscellanous</h2>
<h5><a name="9.1"></a>9.1 Const, Var and Type</h5>
<p>The reserved words var, const and type always appear alone on a
line. These example are correct:</p>
<p>&nbsp;</p>
<pre><b>type</b>
  TMyType = Integer;

<b>const</b>
  MyConstant = 100;

<b>var</b>
  MyVar: Integer;</pre>
<p>&nbsp;</p>
<p>But these are not:</p>
<pre>&nbsp;</pre>
<pre><b>type</b> TMyType = Integer;<br><br><b>const</b> MyConstant = 100;<br><br><b>var</b> MyVar: Integer;</pre>
<p>&nbsp;</p>
<p>Additionally a procedure should only have a single type, const and
var section and, if possible, in that order. For example:</p>
<pre>&nbsp;</pre>
<pre><b>procedure</b> SomeProcedure;<br><b>type</b>
  TMyType = Integer;
<b>const</b>
  ArraySize = 100;
<b>var</b>
  MyArray: <b>array</b> [1..ArraySize] <b>of</b> TMyType;<br><b>begin</b>
  ...
<b>end</b>;</pre>
<h5><a name="9.2"></a>9.2 Conditional compilation</h5>
<p>All JVCL units must include the JVCL.INC file. This file defines a
number of global directives. The include statement should be placed
between the unit and interface keywords. When using any of the
directives from this file, or others for that matter, you should always
repeat the conditional in the ENDIF directive. For example:</p>
<pre>{$IFDEF MSWINDOWS}<br>  // conditionally compiled code<br>{$ENDIF}</pre>
<p>This may seem overkill if the conditionally compiled code only
extends a few lines but is a tremendous visual aid when the code
actually spans multiple pages of code (as is often the case for
platform dependent code). Platform dependent code should use the
conditionals MSWINDOWS, for code intended to run on MS Windows
platforms, WIN32 for windows 32 only code, UNIX for unix compatible
code and LINUX for Linux only code.</p>
<h5><a name="9.3"></a>9.3 Resource strings</h5>
<p>All resourcestrings should be of the format 'Rs'[Category][Name].
[Category] should be (an abbreviation of) the category in which the
code resides, [Name] is a descriptive name for the string itself. For
example, the TJvCriticalSectionEx CreateEx constructor raises an
exception on initialization failure. The exception message is declared
as a resourcestring with the name RsSynchInitCriticalSection.</p>
<p>All resourcestrings must be declared in the global JvResources.pas
file which is included in each JVCL unit. This is to ease translation.
Literal strings should be avoided where possible (use a constant
whenever you can).</p>
<h5><a name="9.4"></a>9.4 Exceptions</h5>
<p>Exceptions are prefixed with 'EJv' instead of 'TJv'. All JVCL
exceptions should be ultimately derived from EJvError which is declared
in JvBase.</p>
<p>When raising an exception you should prefer the
CreateRes(ResStringRec: PResStringRec) constructor for efficiency.
Thus, an exception is raised like this:</p>
<pre><b>raise</b> EJvSomeException.CreateRes(@RsSomeResourceString);</pre>
<h5><a name="9.5"></a>9.5 Categories and routine separation</h5>
<p>Typically each JVCL unit is a single category. For example, JvSynch
contains all kinds of synchronization classes and subroutines. Within a
unit there is usually a further categorization, for example JvSynch has
a number of 'Locked Integer Manipulation' routines which form a
subcategory within this unit. In the interface section each subcategory
is divided using two 100 column width lines in between which there is a
one line description of the subcategory. For example:</p>
<pre>&nbsp;</pre>
<pre><b>function</b> LockedAdd(<b>var</b> Target: Integer; Value: Integer): Integer;<br><b>function</b> LockedCompareExchange(<b>var</b> Target: Integer; Exch, Comp: Integer): Integer;</pre>
<p>&nbsp;</p>
<p>In the implementation section this separation is identical except
that the lines are composed using the equals character (=).</p>
<pre>&nbsp;</pre>
<pre><b>function</b> LockedAdd(<b>var</b> Target: Integer; Value: Integer): Integer;<br><b>asm</b>
  MOV     ECX, EAX</pre>
<p>&nbsp;</p>
<p>In the implementation section each routine or method is separated
from its predecessor using a 80 column width line composed of minus
characters (-).</p>
<pre>&nbsp;</pre>
<pre>  <b>if</b> (L &gt; 0) <b>and</b> (Path[L] &lt;&gt; PathSeparator) <b>then</b> Result := Path + PathSeparator;<br><b>end</b>;<br><br><br><b>function</b> PathAddExtension(<b>const</b> Path, Extension: <b>string</b>): <b>string</b>;<br><b>begin</b>
  Result := Path;
  <b>if</b> (Path &lt;&gt; '') <b>and</b> (ExtractFileExt(Path) = '') <b>and</b> (Extension &lt;&gt; '') <b>then</b>
  <b>begin</b>
    <b>if</b> Extension[1] = '.' <b>then</b>
      Result := Result + Extension
    <b>else</b>
      Result := Result + '.' + Extension;
  <b>end</b>;<br><b>end</b>;<br><br><br><b>function</b> PathAppend(<b>const</b> Path, Append: <b>string</b>): <b>string</b>;<br><b>var</b>
  PathLength: Integer;
  B1, B2: Boolean;
<b>begin</b>
  <b>if</b> Append = '' <b>then</b>
    Result := Path</pre>
<h5><a name="9.6"></a>9.6 Assembler</h5>
<p>While use of Assembler is discouraged, there are cases when it
cannot be avoided. In that case, assembler is to be formatted like this:</p>
<p>&nbsp;</p>
<pre>        REP     MOVSW<br>        JMP     @@2<br>@@1:<br>        LEA     ESI, [ESI + 2 * ECX - 2]<br>        LEA     EDI, [EDI + 2 * ECX - 2]</pre>
<p>&nbsp;</p>
<p>That is, the opcode is indented 8 spaces and the operands are
aligned on the 16th column. Labels should be indented with two spaces
or aligned on the left side and be camel case. All opcodes and
registers should be written fully in uppercase. Numeric labels are
acceptable but a more descriptive name is preferred. General
punctuation formatting still applies, e.g. a single space after each
comma and a space on both sides of an operator (such as the addition
operator +). Additionally, never put labels and commands on the same
line and always prefix labels with the @ character to make the label
scope local. Generically speaking, assembler should be avoided but if
it is used it should be heavily commented.</p>
<h5><a name="9.7"></a>9.7 Local routines</h5>
<p>Local functions should be indented two spaces in their entirety and
separated from the procedure declaration and begin statement by a
single line. If the 'outer' procedure (SomeProcedure in the example)
has local variables these should be declared before the local
procedure, regardless of whether the local procedure needs access to
them. However, local routines should be avoided. Whenever it seems
reasonable to extract code as a local subroutine, think carefully
whether the routine can be made more generic and extracted as a normal,
global routine (of course should be moved to the appropriate unit as
well). This will make the life of C++ Builder users far easier. For
example:</p>
<pre>&nbsp;</pre>
<pre><b>procedure</b> SomeProcedure;<br><b>var</b>
  I: Integer;

  <b>procedure</b> LocalProcedure;<br>  <b>begin</b>
    ...
  <b>end</b>;<br><br><b>begin</b>
  ...
  LocalProcedure;
  ...
<b>end</b>;</pre>
<h5><a name="9.8"></a>9.8 Parameter declarations</h5>
<p>When declaring the parameters list of a procedure, function or
method, observe the following recommendations:</p>
<p>&nbsp;</p>
<ul>
  <li>
    <p>Combine formal parameters of same type into one statement</p>
  </li>
  <li>
    <p>Usage of A in parameter names is discouraged unless it concerns
a method of a class which has as a property which is named identical.</p>
  </li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>Although technically these are not formatting issues, I'd like to
methion them here anyway:</p>
<p>&nbsp;</p>
<ul>
  <li>
    <p>Ordering of parameters should be: input, input./output and
output parameters and within that ordering: most used, least used.
Parameters with default values are, as required by the Object Pascal
language rules, always placed at the back of the list.</p>
  </li>
  <li>
    <p>Use of const for parameter types is recommended even if it's use
does not increases the efficiency of the parameter passing. For
example, a parameter of type Integer should be declared with the const
modifier if that's the semantic meaning of the parameter in question.
However, you MUST not use the const specifier for parameters that are
objects (derived from TObject). This is because of a bug in C++ Builder
which results in unusable header files.<br>
    </p>
  </li>
</ul>
<h5><a name="9.9"></a>9.9 Initialization of global variables</h5>
<p>Global variables are, like class members, automatically initialized
to 0. This has different meaning for different types. For example, and
Integer is initialized to 0 while a pointer is initialized to nil.
Because of this, if the global variable needs to be 0 initialized,
which is often the case, this should not be done explicitly. Instead
you should rely on Delphi to do this for you. This is for efficiency
reasons because it influences how the variable ends up in the
executable and later in memory. If you desire you can add a comment to
indicate reliance on 0 initialization like so:</p>
<p>&nbsp;</p>
<pre>var<br>  MyGlobalVariable: Pointer{ = nil};</pre>
</body>
</html>
